# üèóÔ∏è Backend (NestJS) ‚Äî Full Setup

## 0) Env & packages

```dotenv
# .env
JWT_ACCESS_SECRET=supersecret_access
JWT_REFRESH_SECRET=supersecret_refresh   # (only if you choose JWT refresh, we‚Äôll use opaque tokens here)
ACCESS_TOKEN_TTL=900                    # 15m
REFRESH_TOKEN_TTL_DAYS=7
COOKIE_DOMAIN=.example.com              # optional (for subdomains)
NODE_ENV=production
CORS_ORIGIN=https://app.example.com     # your frontend origin
```

```bash
pnpm add @nestjs/jwt cookie-parser bcrypt
```

---

## 1) App bootstrap (CORS + cookies)

```ts
// main.ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import * as cookieParser from "cookie-parser";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.use(cookieParser());

  app.enableCors({
    origin: process.env.CORS_ORIGIN?.split(",") ?? true,
    credentials: true, // <- sends cookies
    allowedHeaders: ["Content-Type", "Authorization", "X-CSRF-Token"],
    methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  });

  await app.listen(3000);
}
bootstrap();
```

---

## 2) Entities (User + RefreshToken)

```ts
// user.entity.ts
import { Entity, PrimaryGeneratedColumn, Column, OneToMany } from "typeorm";
import { RefreshToken } from "./refresh-token.entity";

@Entity()
export class User {
  @PrimaryGeneratedColumn() id: number;

  @Column({ unique: true }) email: string;

  @Column() passwordHash: string;

  @OneToMany(() => RefreshToken, (rt) => rt.user)
  refreshTokens: RefreshToken[];
}
```

```ts
// refresh-token.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  Index,
} from "typeorm";
import { User } from "./user.entity";

@Entity()
export class RefreshToken {
  @PrimaryGeneratedColumn() id: number;

  @Index({ unique: true })
  @Column()
  tokenHash: string; // store HASH, not raw token

  @Column() expiresAt: Date;

  @Column({ default: false }) revoked: boolean;

  @Column({ nullable: true }) replacedByTokenHash?: string;

  // optional context for security/audit
  @Column({ nullable: true }) userAgent?: string;
  @Column({ nullable: true }) ip?: string;

  @ManyToOne(() => User, (u) => u.refreshTokens, { onDelete: "CASCADE" })
  user: User;

  @CreateDateColumn() createdAt: Date;
}
```

---

## 3) Auth module

```ts
// auth.module.ts
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { JwtModule } from "@nestjs/jwt";
import { User } from "./user.entity";
import { RefreshToken } from "./refresh-token.entity";
import { AuthService } from "./auth.service";
import { AuthController } from "./auth.controller";

@Module({
  imports: [
    TypeOrmModule.forFeature([User, RefreshToken]),
    JwtModule.register({ secret: process.env.JWT_ACCESS_SECRET }),
  ],
  controllers: [AuthController],
  providers: [AuthService],
  exports: [AuthService],
})
export class AuthModule {}
```

---

## 4) Auth service (opaque refresh token, rotation, revocation)

```ts
// auth.service.ts
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository, MoreThan } from "typeorm";
import { JwtService } from "@nestjs/jwt";
import * as bcrypt from "bcrypt";
import { randomBytes } from "crypto";
import { User } from "./user.entity";
import { RefreshToken } from "./refresh-token.entity";

const days = (n: number) => 1000 * 60 * 60 * 24 * n;

@Injectable()
export class AuthService {
  constructor(
    private readonly jwt: JwtService,
    @InjectRepository(User) private users: Repository<User>,
    @InjectRepository(RefreshToken)
    private refreshTokens: Repository<RefreshToken>
  ) {}

  // Example ‚Äî implement real password validation
  async validateUser(email: string, password: string) {
    const user = await this.users.findOne({ where: { email } });
    if (!user) return null;
    // compare password with user.passwordHash
    return user; // assume valid for brevity
  }

  private signAccessToken(user: User) {
    const payload = { sub: user.id, email: user.email, roles: ["user"] };
    return this.jwt.sign(payload, {
      expiresIn: `${process.env.ACCESS_TOKEN_TTL || 900}s`,
      secret: process.env.JWT_ACCESS_SECRET,
    });
  }

  private async mintRefreshToken(
    user: User,
    ctx?: { ua?: string; ip?: string }
  ) {
    const raw = randomBytes(64).toString("hex"); // opaque random
    const hash = await bcrypt.hash(raw, 10);

    const token = this.refreshTokens.create({
      tokenHash: hash,
      user,
      expiresAt: new Date(
        Date.now() + days(Number(process.env.REFRESH_TOKEN_TTL_DAYS || 7))
      ),
      userAgent: ctx?.ua,
      ip: ctx?.ip,
    });
    await this.refreshTokens.save(token);

    return { raw, hash };
  }

  async issueLoginTokens(user: User, ctx?: { ua?: string; ip?: string }) {
    const accessToken = this.signAccessToken(user);
    const { raw, hash } = await this.mintRefreshToken(user, ctx);
    return { accessToken, refreshTokenRaw: raw, refreshTokenHash: hash };
  }

  async refreshUsingCookie(
    userId: number,
    rawTokenFromCookie: string,
    ctx?: { ua?: string; ip?: string }
  ) {
    const user = await this.users.findOne({
      where: { id: userId },
      relations: ["refreshTokens"],
    });
    if (!user) throw new UnauthorizedException();

    // Find a valid, unexpired, non-revoked refresh token matching the cookie
    const candidates = await this.refreshTokens.find({
      where: {
        user: { id: userId },
        revoked: false,
        expiresAt: MoreThan(new Date()),
      },
      order: { id: "DESC" },
    });

    const match = await this.findMatchingToken(rawTokenFromCookie, candidates);
    if (!match) throw new UnauthorizedException("Invalid refresh token");

    // ROTATE: revoke old, mint new
    match.revoked = true;
    const newRaw = randomBytes(64).toString("hex");
    const newHash = await bcrypt.hash(newRaw, 10);
    match.replacedByTokenHash = newHash;
    await this.refreshTokens.save(match);

    const newRecord = this.refreshTokens.create({
      tokenHash: newHash,
      user,
      expiresAt: new Date(
        Date.now() + days(Number(process.env.REFRESH_TOKEN_TTL_DAYS || 7))
      ),
      userAgent: ctx?.ua,
      ip: ctx?.ip,
    });
    await this.refreshTokens.save(newRecord);

    const newAccess = this.signAccessToken(user);
    return { accessToken: newAccess, newRefreshRaw: newRaw };
  }

  private async findMatchingToken(raw: string, records: RefreshToken[]) {
    for (const rec of records) {
      if (await bcrypt.compare(raw, rec.tokenHash)) return rec;
    }
    return null;
  }

  async revokeRefreshToken(userId: number, raw: string) {
    const records = await this.refreshTokens.find({
      where: { user: { id: userId }, revoked: false },
    });
    const match = await this.findMatchingToken(raw, records);
    if (!match) return;
    match.revoked = true;
    await this.refreshTokens.save(match);
  }

  async revokeAllUserTokens(userId: number) {
    await this.refreshTokens.update(
      { user: { id: userId }, revoked: false },
      { revoked: true }
    );
  }
}
```

---

## 5) Cookie helpers

```ts
// cookie.util.ts
import { Response } from "express";

export function setRefreshCookie(res: Response, token: string) {
  const isProd = process.env.NODE_ENV === "production";
  const sameSite = isProd ? ("none" as const) : ("lax" as const);

  res.cookie("rt", token, {
    httpOnly: true,
    secure: isProd, // must be true when SameSite=None
    sameSite,
    path: "/auth/refresh", // limit surface; or '/'
    maxAge:
      Number(process.env.REFRESH_TOKEN_TTL_DAYS || 7) * 24 * 60 * 60 * 1000,
    domain: process.env.COOKIE_DOMAIN || undefined, // optional for subdomains
  });
}

export function clearRefreshCookie(res: Response) {
  res.clearCookie("rt", {
    path: "/auth/refresh",
    domain: process.env.COOKIE_DOMAIN || undefined,
  });
}
```

---

## 6) Controller (login / refresh / logout)

```ts
// auth.controller.ts
import {
  Body,
  Controller,
  Post,
  Req,
  Res,
  UnauthorizedException,
} from "@nestjs/common";
import { AuthService } from "./auth.service";
import { Request, Response } from "express";
import { setRefreshCookie, clearRefreshCookie } from "../common/cookie.util";

@Controller("auth")
export class AuthController {
  constructor(private readonly auth: AuthService) {}

  @Post("login")
  async login(
    @Body() body: { email: string; password: string },
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response
  ) {
    const user = await this.auth.validateUser(body.email, body.password);
    if (!user) throw new UnauthorizedException();

    const { accessToken, refreshTokenRaw } = await this.auth.issueLoginTokens(
      user,
      {
        ua: req.headers["user-agent"],
        ip: req.ip,
      }
    );

    setRefreshCookie(res, refreshTokenRaw);
    // Send access token in body (client stores in memory)
    return { accessToken };
  }

  // Called by Axios interceptor when it sees 401
  @Post("refresh")
  async refresh(
    @Req() req: Request,
    @Res({ passthrough: true }) res: Response
  ) {
    const rt = req.cookies?.["rt"];
    if (!rt) throw new UnauthorizedException("No refresh cookie");

    // You may store userId in the refresh cookie payload if using JWT refresh.
    // For opaque tokens, decode from DB association. Here we require userId in header for demo:
    const userId = Number(req.headers["x-user-id"]); // or store userId in a signed cookie
    if (!userId) throw new UnauthorizedException("Missing user id context");

    const { accessToken, newRefreshRaw } = await this.auth.refreshUsingCookie(
      userId,
      rt,
      {
        ua: req.headers["user-agent"],
        ip: req.ip,
      }
    );

    setRefreshCookie(res, newRefreshRaw); // rotation
    return { accessToken };
  }

  @Post("logout")
  async logout(@Req() req: Request, @Res({ passthrough: true }) res: Response) {
    const rt = req.cookies?.["rt"];
    const userId = Number(req.headers["x-user-id"]); // same note as above
    if (rt && userId) {
      await this.auth.revokeRefreshToken(userId, rt);
    }
    clearRefreshCookie(res);
    return { ok: true };
  }
}
```

> **Notes**
>
> - In a production build you‚Äôd typically avoid needing `x-user-id` and instead:
>
>   - Use a **JWT refresh cookie** that includes `sub` (signed), **or**
>   - Store a **session id** in a separate signed cookie mapping to userId server-side.
>
> - Above shows the opaque-token + DB approach clearly; adapt to your chosen pattern.

---

# üñ•Ô∏è Frontend ‚Äî Axios setup (with refresh & retry)

Goal:

- Keep **access token** in memory only.
- Let the **refresh cookie** be handled by the browser (HTTP-only).
- Automatically **refresh & retry** once on `401`.

```ts
// api.ts
import axios from "axios";

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || "https://api.example.com",
  withCredentials: true, // <- send/receive cookies
});

let accessToken: string | null = null;
let refreshingPromise: Promise<string | null> | null = null;

export function setAccessToken(token: string | null) {
  accessToken = token;
}

api.interceptors.request.use((config) => {
  if (accessToken) {
    config.headers = config.headers ?? {};
    config.headers.Authorization = `Bearer ${accessToken}`;
  }
  // If your backend expects user context for refresh (as shown above)
  if (!config.headers["X-User-Id"] && accessToken) {
    // Decode JWT to set user id if you embedded it in access token (optional)
    try {
      const payload = JSON.parse(atob(accessToken.split(".")[1]));
      config.headers["X-User-Id"] = payload.sub;
    } catch {}
  }
  return config;
});

api.interceptors.response.use(
  (res) => res,
  async (error) => {
    const original = error.config;

    // If unauthorized and not already retried ‚Üí try refresh
    if (error.response?.status === 401 && !original._retry) {
      original._retry = true;

      // single in-flight refresh
      if (!refreshingPromise) {
        refreshingPromise = api
          .post("/auth/refresh", null) // cookie is sent automatically
          .then((r) => r.data?.accessToken || null)
          .catch(() => null)
          .finally(() => {
            // Reset after completion to allow future refreshes
            const t = refreshingPromise;
            refreshingPromise = null;
            return t;
          });
      }

      const newAccess = await refreshingPromise;
      if (newAccess) {
        setAccessToken(newAccess);
        original.headers = original.headers ?? {};
        original.headers.Authorization = `Bearer ${newAccess}`;
        return api(original); // retry
      }
    }

    return Promise.reject(error);
  }
);

export default api;
```

### Login flow example

```ts
// authClient.ts
import api, { setAccessToken } from "./api";

export async function login(email: string, password: string) {
  const { data } = await api.post("/auth/login", { email, password });
  setAccessToken(data.accessToken);
}

export async function logout() {
  try {
    await api.post("/auth/logout");
  } finally {
    setAccessToken(null);
  }
}
```

> The browser stores the refresh cookie automatically (HTTP-only).
> Access token is kept in memory and added to `Authorization` header.
> On `401`, interceptor calls `/auth/refresh` and retries once.

---

# ‚úÖ Security & Ops Checklist

- **HTTP-only, Secure, SameSite** cookies for refresh token

  - `Secure=true` when on HTTPS and `SameSite=None` for cross-site apps

- **Opaque refresh tokens** stored **hashed** in DB (as above)
- **Rotation** on every refresh; revoke the old token record
- **Revoke all** on password change / logoutAll
- **Short access tokens** (5‚Äì15 minutes)
- Consider **device/session table** (track UA/IP, lastUsed)
- Optionally add **CSRF** defense for refresh route (double-submit token header)

---

# üß≠ Variations

- **JWT refresh token** (instead of opaque): put `sub` in JWT and verify via `JWT_REFRESH_SECRET`; still store a jti to allow revocation if you need it.
- **Path scoping**: set cookie `path: '/auth/refresh'` so it‚Äôs sent **only** to the refresh route.
- **Subdomains**: set `domain: .example.com` if API and app are on different subdomains.
