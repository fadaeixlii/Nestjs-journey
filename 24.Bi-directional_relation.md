## ðŸ” What is a Bi-directional Relationship?

A **bi-directional relationship** is when **two tables/entities reference each other**, and you can **navigate from A to B and B to A**.

Example:

- A `User` has many `Posts`
- Each `Post` belongs to a `User`

So:

- From `User` â†’ you can access their `posts`
- From `Post` â†’ you can access the `author` (user)

---

## ðŸ§© Part 1: In SQL/PostgreSQL

### A. Foreign Key Setup

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  user_id INTEGER REFERENCES users(id)
);
```

- `posts.user_id` is a **foreign key** to `users.id`
- You can query both directions using `JOIN`s

### B. Bi-directional Navigation via SQL

```sql
-- Get all posts with their author's name
SELECT p.title, u.name
FROM posts p
JOIN users u ON p.user_id = u.id;

-- Get all users with their posts
SELECT u.name, p.title
FROM users u
LEFT JOIN posts p ON p.user_id = u.id;
```

---

## âš™ï¸ Part 2: In NestJS with TypeORM

TypeORM makes bi-directional relationships **easy to model using decorators**.

### Example: OneToMany / ManyToOne (User â†” Posts)

```ts
// user.entity.ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @OneToMany(() => Post, (post) => post.author) // ðŸ‘ˆ relation back to Post
  posts: Post[];
}
```

```ts
// post.entity.ts
@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @ManyToOne(() => User, (user) => user.posts) // ðŸ‘ˆ relation back to User
  author: User;

  @Column()
  userId: number; // optional but good for filtering
}
```

> TypeORM links them **both ways** using the 2nd argument: `(otherEntity) => otherEntity.property`.

---

### Fetching Relations

```ts
// posts.service.ts
async getPostWithUser(id: number) {
  return this.postRepo.findOne({
    where: { id },
    relations: ['author'],
  });
}

async getUserWithPosts(userId: number) {
  return this.userRepo.findOne({
    where: { id: userId },
    relations: ['posts'],
  });
}
```

---

## ðŸ”€ Other Bi-directional Relationship Types

### 1. **One-to-One (e.g. User â†” Profile)**

```ts
// user.entity.ts
@OneToOne(() => Profile, (profile) => profile.user)
@JoinColumn() // owns the relation
profile: Profile;

// profile.entity.ts
@OneToOne(() => User, (user) => user.profile)
user: User;
```

### 2. **Many-to-Many (e.g. Students â†” Courses)**

```ts
// student.entity.ts
@ManyToMany(() => Course, (course) => course.students)
@JoinTable()
courses: Course[];

// course.entity.ts
@ManyToMany(() => Student, (student) => student.courses)
students: Student[];
```

---

## ðŸ”§ Best Practices

| Practice                          | Description                                             |
| --------------------------------- | ------------------------------------------------------- |
| Use bi-directional only if needed | Avoid unnecessary complexity if you only query one side |
| Use `JoinColumn` carefully        | Only one side of a OneToOne needs it                    |
| Always specify inverse side       | Helps prevent circular serialization                    |
| Avoid lazy loading                | Prefer `relations: ['x']` for clarity/performance       |
| Normalize foreign keys            | Add `userId` even if you have `author: User`            |

---

## âš ï¸ Common Mistakes

| Mistake                               | Fix                                                |
| ------------------------------------- | -------------------------------------------------- |
| Missing `@JoinColumn()` in OneToOne   | Add to the owner side                              |
| Forgetting inverse side `(x) => x.y`  | Required for correct mapping                       |
| Infinite loops when returning objects | Use DTOs or `@Exclude` from `class-transformer`    |
| Lazy loading in production            | Avoid, use eager loading or `relations` in queries |

---

## ðŸ§ª Bonus: QueryBuilder for More Control

```ts
const posts = await this.postRepo
  .createQueryBuilder("post")
  .leftJoinAndSelect("post.author", "author")
  .where("author.id = :id", { id: 1 })
  .getMany();
```
