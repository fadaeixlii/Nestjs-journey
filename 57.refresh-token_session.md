# 🧱 Concept: JWT access + opaque session (no cookies)

- **Access token (JWT)**: short-lived (5–15m), sent as `Authorization: Bearer <access>`.
- **Session**: an **opaque server-side record** that carries refresh capability.

  - Client stores **`sessionId`** (UUID) and a **`refreshToken`** (random 64B string).
  - Refresh uses **both**: `X-Session-Id: <uuid>` header + `refreshToken` in body (or header).
  - Rotation on every refresh: issue **new refreshToken**, mark old one **revoked**.

- **Logout** revokes this session; **Logout-all** revokes all user sessions.
- No cookies involved.

---

# 🗃️ Schema (TypeORM)

```ts
// session.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  Index,
  CreateDateColumn,
  UpdateDateColumn,
} from "typeorm";
import { User } from "../users/user.entity";

@Entity({ name: "sessions" })
export class Session {
  @PrimaryGeneratedColumn("uuid")
  id: string; // sessionId returned to client

  @Index()
  @ManyToOne(() => User, { onDelete: "CASCADE" })
  user: User;

  @Column({ length: 100 })
  refreshTokenHash: string; // bcrypt hash of refresh token

  @Column({ type: "timestamptz" })
  expiresAt: Date; // session expiry (e.g., 7–30d)

  @Column({ default: false })
  revoked: boolean;

  @Column({ type: "timestamptz", nullable: true })
  revokedAt?: Date;

  @Column({ nullable: true })
  revokeReason?: string;

  @Column({ type: "timestamptz" })
  lastUsedAt: Date;

  @Column({ nullable: true })
  userAgent?: string;

  @Column({ nullable: true })
  ip?: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

---

# 🧩 Providers (clean separation)

```
auth/
  tokens/
    token.service.ts      # sign/verify access JWT
  sessions/
    session.repository.ts # (optional) custom repo helpers
    session.service.ts    # create/refresh/rotate/revoke/touch
  auth.service.ts         # orchestrates login/refresh/logout
  guards/
    access-token.guard.ts # verifies access JWT on protected routes
    session-refresh.guard.ts # (optional) validates session+refresh input for /refresh
  controllers/
    auth.controller.ts
users/
  user.entity.ts
```

### `TokenService` – JWT only

```ts
// token.service.ts
import { Injectable } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";

@Injectable()
export class TokenService {
  constructor(private jwt: JwtService) {}

  signAccess(payload: { sub: number; email: string; roles: string[] }) {
    return this.jwt.sign(payload, {
      secret: process.env.JWT_ACCESS_SECRET!,
      expiresIn: process.env.ACCESS_TTL ?? "15m",
    });
  }

  verifyAccess(token: string) {
    return this.jwt.verify(token, { secret: process.env.JWT_ACCESS_SECRET! });
  }
}
```

### `SessionService` – the stateful brain

```ts
// session.service.ts
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { Repository, MoreThan } from "typeorm";
import { InjectRepository } from "@nestjs/typeorm";
import { Session } from "./session.entity";
import * as bcrypt from "bcrypt";
import { randomBytes } from "crypto";
import { User } from "../../users/user.entity";

const days = (n: number) => 1000 * 60 * 60 * 24 * n;

@Injectable()
export class SessionService {
  constructor(
    @InjectRepository(Session) private sessions: Repository<Session>
  ) {}

  async create(user: User, ctx?: { ua?: string; ip?: string }) {
    const raw = randomBytes(64).toString("hex");
    const hash = await bcrypt.hash(raw, 10);

    const sess = this.sessions.create({
      user,
      refreshTokenHash: hash,
      expiresAt: new Date(
        Date.now() + days(Number(process.env.SESSION_TTL_DAYS || 30))
      ),
      lastUsedAt: new Date(),
      userAgent: ctx?.ua,
      ip: ctx?.ip,
    });
    const saved = await this.sessions.save(sess);
    return { sessionId: saved.id, refreshToken: raw };
  }

  async rotate(
    sessionId: string,
    refreshTokenRaw: string,
    ctx?: { ua?: string; ip?: string }
  ) {
    const session = await this.sessions.findOne({
      where: { id: sessionId, revoked: false, expiresAt: MoreThan(new Date()) },
      relations: ["user"],
    });
    if (!session) throw new UnauthorizedException("Invalid session");

    const ok = await bcrypt.compare(refreshTokenRaw, session.refreshTokenHash);
    if (!ok) throw new UnauthorizedException("Invalid refresh token");

    // rotate token
    const newRaw = randomBytes(64).toString("hex");
    const newHash = await bcrypt.hash(newRaw, 10);

    session.refreshTokenHash = newHash;
    session.lastUsedAt = new Date();
    session.userAgent = ctx?.ua ?? session.userAgent;
    session.ip = ctx?.ip ?? session.ip;

    await this.sessions.save(session);
    return { user: session.user, newRefreshToken: newRaw };
  }

  async revoke(sessionId: string, reason?: string) {
    await this.sessions.update(
      { id: sessionId },
      { revoked: true, revokedAt: new Date(), revokeReason: reason ?? null }
    );
  }

  async revokeAll(userId: number, reason?: string) {
    await this.sessions.update(
      { user: { id: userId }, revoked: false },
      { revoked: true, revokedAt: new Date(), revokeReason: reason ?? null }
    );
  }
}
```

### `AuthService` – orchestration

```ts
// auth.service.ts
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { TokenService } from "./tokens/token.service";
import { SessionService } from "./sessions/session.service";
import { Repository } from "typeorm";
import { InjectRepository } from "@nestjs/typeorm";
import { User } from "../users/user.entity";

@Injectable()
export class AuthService {
  constructor(
    private tokens: TokenService,
    private sessions: SessionService,
    @InjectRepository(User) private users: Repository<User>
  ) {}

  async validateUser(email: string, password: string) {
    const user = await this.users.findOne({ where: { email } });
    // TODO: check password hash
    return user ?? null;
  }

  async login(
    email: string,
    password: string,
    ctx?: { ua?: string; ip?: string }
  ) {
    const user = await this.validateUser(email, password);
    if (!user) throw new UnauthorizedException();

    const accessToken = this.tokens.signAccess({
      sub: user.id,
      email: user.email,
      roles: ["user"],
    });
    const { sessionId, refreshToken } = await this.sessions.create(user, ctx);

    return { accessToken, sessionId, refreshToken };
  }

  async refresh(
    sessionId: string,
    refreshToken: string,
    ctx?: { ua?: string; ip?: string }
  ) {
    const { user, newRefreshToken } = await this.sessions.rotate(
      sessionId,
      refreshToken,
      ctx
    );
    const accessToken = this.tokens.signAccess({
      sub: user.id,
      email: user.email,
      roles: ["user"],
    });
    return { accessToken, sessionId, refreshToken: newRefreshToken };
  }

  async logout(sessionId: string) {
    await this.sessions.revoke(sessionId, "logout");
  }

  async logoutAll(userId: number) {
    await this.sessions.revokeAll(userId, "logout_all");
  }
}
```

### Guards

**Access guard** (protects APIs with JWT):

```ts
// guards/access-token.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from "@nestjs/common";
import { TokenService } from "../tokens/token.service";

@Injectable()
export class AccessTokenGuard implements CanActivate {
  constructor(private tokens: TokenService) {}

  canActivate(ctx: ExecutionContext): boolean {
    const req = ctx.switchToHttp().getRequest();
    const auth = req.headers["authorization"] as string | undefined;
    if (!auth?.startsWith("Bearer "))
      throw new UnauthorizedException("Missing token");
    const token = auth.slice(7);
    try {
      req.user = this.tokens.verifyAccess(token);
      return true;
    } catch {
      throw new UnauthorizedException("Invalid/expired token");
    }
  }
}
```

_(Optional)_ A small guard to validate the **shape** of refresh input for `/auth/refresh`:

```ts
// guards/session-refresh.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  BadRequestException,
} from "@nestjs/common";

@Injectable()
export class SessionRefreshGuard implements CanActivate {
  canActivate(ctx: ExecutionContext): boolean {
    const req = ctx.switchToHttp().getRequest();
    if (!req.headers["x-session-id"])
      throw new BadRequestException("Missing X-Session-Id");
    if (!req.body?.refreshToken)
      throw new BadRequestException("Missing refreshToken");
    return true;
  }
}
```

### Controller

```ts
// auth.controller.ts
import { Body, Controller, Post, Req, UseGuards } from "@nestjs/common";
import { AuthService } from "../auth.service";
import { Request } from "express";
import { AccessTokenGuard } from "../guards/access-token.guard";
import { SessionRefreshGuard } from "../guards/session-refresh.guard";

@Controller("auth")
export class AuthController {
  constructor(private auth: AuthService) {}

  @Post("login")
  async login(
    @Body() body: { email: string; password: string },
    @Req() req: Request
  ) {
    return this.auth.login(body.email, body.password, {
      ua: req.headers["user-agent"] as string,
      ip: req.ip,
    });
  }

  @Post("refresh")
  @UseGuards(SessionRefreshGuard)
  async refresh(@Req() req: Request, @Body() body: { refreshToken: string }) {
    const sessionId = req.headers["x-session-id"] as string;
    return this.auth.refresh(sessionId, body.refreshToken, {
      ua: req.headers["user-agent"] as string,
      ip: req.ip,
    });
  }

  @Post("logout")
  @UseGuards(AccessTokenGuard)
  async logout(@Req() req: any) {
    const sessionId = req.headers["x-session-id"] as string; // client sends active session id
    await this.auth.logout(sessionId);
    return { ok: true };
  }

  @Post("logout-all")
  @UseGuards(AccessTokenGuard)
  async logoutAll(@Req() req: any) {
    await this.auth.logoutAll(Number(req.user.sub));
    return { ok: true };
  }
}
```

---

# 🧠 How client uses it (no cookies)

- **Login** → store `accessToken` in memory, **`sessionId`** & **`refreshToken`** in secure storage (mobile keystore) or memory while app open.
- **Every API call** → `Authorization: Bearer <accessToken>`.
- On **401** → call `/auth/refresh` with:

  - Header: `X-Session-Id: <sessionId>`
  - Body: `{ "refreshToken": "<refreshToken>" }`
  - Replace tokens with response (rotation).

- **Logout** → call `/auth/logout` with `X-Session-Id`.

---

# 🔒 Security notes (no-cookies edition)

- Treat **refreshToken** like a password; show it **only** to `/auth/refresh`.
- Always **hash** refresh tokens in DB (bcrypt/argon2).
- **Rotate** on every refresh; if you see an old token being reused → **revoke all** sessions for that user (stolen token).
- Use **short** access TTL (5–15m), **longer** session TTL (7–30d).
- Rate-limit `/auth/refresh`.
- Store session metadata (UA/IP) for anomaly detection.

---

# 📏 Storage sizing estimates (revocation-friendly)

Rough per-session row (Postgres):

- UUID (16B), 5–8 timestamps, booleans, FK, **bcrypt hash (\~60B)**, indexes → **\~1.5–2.5 KB/row** including index overhead.

**Small** product

- \~10k MAU, avg 2 active sessions/user/month → **20k sessions/mo**
- Keep 90 days: **\~60k rows** → **\~120 MB** (2 KB/row)

**Medium** product

- \~100k MAU, 2 sessions/user/month → **200k/mo**
- Keep 6 months: **\~1.2M rows** → **\~2.4 GB**

**Large** product

- \~1M MAU, 2 sessions/user/month → **2M/mo**
- Keep 12 months: **\~24M rows** → **\~48 GB**

Levers to control growth:

- Prune revoked/expired sessions past 30–90 days.
- Partition `sessions` by month (native PG partitioning).
- Keep only **last N active** sessions per user.
- Archive to cold storage (S3) if you need long audit history.

---

# ✅ Best practices summary

- Keep **JWT access** stateless; keep **sessions stateful** for refresh & revoke.
- **No cookies**: carry `sessionId` in `X-Session-Id` header, `refreshToken` in body/header.
- **Strict rotation** + **hashing** + **revocation**.
- Separate providers: `TokenService`, `SessionService`, `AuthService`, per-route guards.
- Add **logging** on rotate/revoke; monitor anomalies (UA/IP changes).
- Document in Swagger: login/refresh/logout request/response; mark protected routes with BearerAuth.
