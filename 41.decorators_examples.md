### What Are Decorators?

**Definition**: Decorators are a TypeScript feature (also used in NestJS) that allow you to add metadata or modify the behavior of classes, methods, properties, or parameters at design time. They are functions executed when the code is defined, not at runtime, and are prefixed with `@`.

**Purpose in NestJS**:

- Enhance code by adding functionality (e.g., authentication, logging) without cluttering business logic.
- Promote reusability and maintainability through declarative syntax.
- Common in NestJS for routing (`@Get`), guards (`@UseGuards`), and dependency injection (`@Inject`).

**Types of Decorators**:

1. **Class Decorators**: Modify entire classes (e.g., `@Controller`).
2. **Method Decorators**: Alter methods (e.g., `@Get`, `@Post`).
3. **Parameter Decorators**: Modify method parameters (e.g., `@Body`, `@Query`).
4. **Property Decorators**: Enhance class properties (less common in NestJS).

**Real-World Fit**: In your election system, decorators can secure endpoints (e.g., restrict `POST /elections` to admins) or log authentication actions (e.g., track `AdminUser` logins).

---

### How Decorators Work

- Decorators are enabled in `tsconfig.json` with `"experimentalDecorators": true` and `"emitDecoratorMetadata": true`.
- They receive metadata about the target (class, method, or parameter) and can modify behavior or attach metadata via the `reflect-metadata` package.
- In NestJS, decorators often work with middleware, guards, or interceptors.

**Example**: The `@Get()` decorator in NestJS registers a method as an HTTP GET endpoint handler.

---

### Creating Custom Decorators

I'll explain how to create custom decorators for class methods and parameters, focusing on authentication use cases in your election system.

#### 1. Custom Method Decorator for Role-Based Access

**Purpose**: Restrict endpoint access based on user roles (e.g., `admin` for managing `Election`, `voter` for `ElectionOption`).

**Steps**:

1. Create a `SetMetadata` function from `@nestjs/common` to attach role metadata to methods.
2. Define a `@Roles` decorator to specify allowed roles.
3. Create a `RolesGuard` to check the JWT payloadâ€™s role against the metadata.
4. Apply `@Roles` to controller methods (e.g., `POST /elections`).
5. Integrate with `JwtAuthGuard` from your JWT structure.
6. Throw `ForbiddenException` for unauthorized roles.
7. Test with mock `AdminUser` data.

**Code Example**:

```typescript
import {
  SetMetadata,
  UseGuards,
  Controller,
  Post,
  ForbiddenException,
} from "@nestjs/common";
import { JwtAuthGuard } from "./jwt-auth.guard";
import { ExecutionContext, Injectable, CanActivate } from "@nestjs/common";

// Method Decorator
export const Roles = (...roles: string[]) => SetMetadata("roles", roles);

// Guard to Check Roles
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    @InjectRepository(AdminUser)
    private adminUserRepository: Repository<AdminUser>
  ) {}
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const user = request.user; // Set by JwtAuthGuard
    const roles = Reflect.getMetadata("roles", context.getHandler());
    if (!roles || !user || !roles.includes(user.role)) {
      throw new ForbiddenException("Insufficient role permissions");
    }
    return true;
  }
}

// Controller Example
@Controller("elections")
export class ElectionsController {
  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles("admin")
  async createElection(@Body() createElectionDto: CreateElectionDto) {
    return { message: "Election created" };
  }
}
```

**Real-World Example**: An admin (`role: 'admin'`) creates an `Election`. The `@Roles('admin')` decorator ensures only admins access `POST /elections`. A voter (`role: 'voter'`) trying to access it gets a `403 Forbidden` error.

#### 2. Custom Parameter Decorator for Current User

**Purpose**: Inject the authenticated `AdminUser` (from JWT) into controller methods for personalized actions (e.g., logging user actions).

**Steps**:

1. Create a `@CurrentUser` decorator using `createParamDecorator` from `@nestjs/common`.
2. Extract the user from the request (set by `JwtAuthGuard`).
3. Validate the user exists, throwing `UnauthorizedException` if not.
4. Apply `@CurrentUser` to method parameters in controllers.
5. Use with `JwtAuthGuard` to ensure the user is authenticated.
6. Integrate with `Paginate` for endpoints like `GET /elections`.

**Code Example**:

```typescript
import {
  createParamDecorator,
  ExecutionContext,
  UnauthorizedException,
} from "@nestjs/common";
import { AdminUser } from "./admin-user.entity";

// Parameter Decorator
export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): AdminUser => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user as AdminUser;
    if (!user) throw new UnauthorizedException("User not authenticated");
    return user;
  }
);

// Controller Example
@Controller("elections")
export class ElectionsController {
  constructor(private electionsService: ElectionsService) {}
  @Get("my-elections")
  @UseGuards(JwtAuthGuard)
  async getMyElections(
    @CurrentUser() user: AdminUser,
    @Query() pagination: Paginate.PaginateInput
  ) {
    const paginate = Paginate.mk(pagination, 10 as NaturalNumber);
    return this.electionsService.findByCreator(user.id, paginate);
  }
}
```

**Real-World Example**: An admin retrieves their created `Election` records via `GET /elections/my-elections`. The `@CurrentUser` decorator injects the authenticated `AdminUser`, and the endpoint uses `Paginate` to return paginated results.

#### 3. Custom Method Decorator for Authentication Logging

**Purpose**: Log authentication actions (e.g., login attempts) to an `AuthLog` entity for audit trails.

**Steps**:

1. Create an `AuthLog` entity with fields: `userId: Id`, `action`, `timestamp`, `ip`.
2. Define a `@LogAuthAction` decorator to log method executions.
3. Use `SetMetadata` to attach action metadata (e.g., `login`, `logout`).
4. Create an `AuthLoggingInterceptor` to save logs to `AuthLog` using a transaction.
5. Apply `@LogAuthAction` to auth endpoints (e.g., `POST /login`).
6. Integrate with `JwtAuthGuard` for user context.
7. Use `nestjs-zod` for log validation.

**Code Example**:

```typescript
import {
  SetMetadata,
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { Observable } from "rxjs";
import { tap } from "rxjs/operators";
import { AuthLog } from "./auth-log.entity";
import { Id } from "./id-maker";

// Method Decorator
export const LogAuthAction = (action: string) =>
  SetMetadata("authAction", action);

// Interceptor for Logging
@Injectable()
export class AuthLoggingInterceptor implements NestInterceptor {
  constructor(
    @InjectRepository(AuthLog) private authLogRepository: Repository<AuthLog>
  ) {}
  async intercept(
    context: ExecutionContext,
    next: CallHandler
  ): Promise<Observable<any>> {
    const request = context.switchToHttp().getRequest();
    const user = request.user as AdminUser;
    const action = Reflect.getMetadata("authAction", context.getHandler());
    return next.handle().pipe(
      tap(async () => {
        if (user && action) {
          const log = new AuthLog();
          log.userId = user.id;
          log.action = action;
          log.timestamp = new Date();
          log.ip = request.ip;
          await this.authLogRepository.save(log);
        }
      })
    );
  }
}

// Controller Example
@Controller("auth")
export class AuthController {
  constructor(private authService: AuthService) {}
  @Post("login")
  @UseGuards(JwtAuthGuard)
  @UseInterceptors(AuthLoggingInterceptor)
  @LogAuthAction("login")
  async login(@Body() signInDto: SignInDto) {
    return this.authService.signIn(signInDto);
  }
}
```

**Real-World Example**: An admin logs into the election system via `POST /auth/login`. The `@LogAuthAction('login')` decorator triggers the `AuthLoggingInterceptor` to save a log entry (`userId: Id`, `action: 'login'`, `ip`) to `AuthLog`.

---

### Explanation of Decorators

- **Method Decorators (`@Roles`, `@LogAuthAction`)**:

  - Use `SetMetadata` to attach metadata (e.g., roles, action type).
  - Work with guards (`RolesGuard`) or interceptors (`AuthLoggingInterceptor`) to enforce logic.
  - **Benefit**: Declarative access control and logging, keeping controllers clean.
  - **Election Fit**: `@Roles('admin')` restricts `POST /elections` to admins; `@LogAuthAction` tracks login attempts.

- **Parameter Decorator (`@CurrentUser`)**:

  - Uses `createParamDecorator` to extract data (e.g., user) from the request.
  - Simplifies access to authenticated user data in controllers.
  - **Benefit**: Avoids repetitive request parsing, integrates with `JwtAuthGuard`.
  - **Election Fit**: `@CurrentUser` injects `AdminUser` for personalized endpoints like `GET /elections/my-elections`.

- **Real-World Use**:
  - Admins manage `Election` with `@Roles('admin')`.
  - Voters access `ElectionOption` with `@CurrentUser` to vote.
  - Audit logs track `AdminUser` actions with `@LogAuthAction`.

---

### Best Practices for Custom Decorators

- **Keep Simple**: Decorators should focus on one responsibility (e.g., role checking, logging).
- **Use Metadata**: Leverage `reflect-metadata` for flexible, reusable logic.
- **Integrate with Guards/Interceptors**: Pair decorators with guards (e.g., `JwtAuthGuard`) or interceptors for enforcement.
- **Type Safety**: Use `Id` from `IdMaker` and `nestjs-zod` for validation.
- **Error Handling**: Throw specific exceptions (e.g., `ForbiddenException`, `UnauthorizedException`).
- **Testability**: Test decorators with mock requests to ensure correct metadata and behavior.
- **Reusability**: Design decorators to work across controllers (e.g., auth, elections).

---

### Comparison with JWT Code

**Provided JWT Code** (from previous question):

- Uses raw `jsonwebtoken` for signing/verifying tokens.
- No explicit decorators for role checks or logging.
- Relies on controller/service logic for auth enforcement.

**New Structure with Decorators**:

- Integrates with `@nestjs/jwt` and `passport-jwt` for cleaner JWT handling.
- Uses `@Roles` for declarative role-based access, reducing service clutter.
- Adds `@CurrentUser` for easy user access in controllers.
- Implements `@LogAuthAction` for audit trails, enhancing security.
- **Improvement**: Decorators make code declarative, modular, and easier to maintain, aligning with NestJS conventions.

**Real-World Example**: In your election system, `@Roles('admin')` on `POST /elections` ensures only admins create elections, `@CurrentUser` simplifies fetching the voterâ€™s `AdminUser` for `POST /votes`, and `@LogAuthAction` logs all auth actions to `AuthLog` for compliance.

---

### Integration with Election System

- **Entities**: Use `AdminUser` (with `id: Id`, `role`) for authentication, `AuthLog` for logging.
- **JWT**: Builds on the JWT structure, using `JwtAuthGuard` with decorators.
- **Pagination**: Combine with `Paginate` for endpoints like `GET /auth/logs`.
- **Type Safety**: Use `Id` from `IdMaker` and `NaturalNumber` for log counts.

Let me know if you want to expand another auth section (e.g., refresh tokens) or deepen the decorator implementation with more examples!
