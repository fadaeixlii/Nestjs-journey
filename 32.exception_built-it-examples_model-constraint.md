### Introduction to Exception Handling in NestJS

NestJS provides a robust built-in exceptions layer that automatically handles unhandled exceptions across the application, transforming them into structured HTTP responses (e.g., JSON with status code and message). This layer is extensible, allowing developers to throw exceptions manually, create custom ones, and use exception filters to intercept and customize error handling. Exceptions in NestJS are typically subclasses of `HttpException`, which includes a status code and response body.

The core mechanism:

- **Throwing Exceptions**: Use `throw new ExceptionName('message')` in controllers, services, or guards.
- **Handling**: Uncaught exceptions are caught by the global exceptions filter. You can create custom filters with `@Catch()` to handle specific exceptions.
- **Response Format**: By default, exceptions return JSON like `{ statusCode: 400, message: 'Error message', error: 'Bad Request' }`.
- **Best Practices**: Use built-in exceptions for common HTTP errors, custom ones for domain-specific issues, and filters for logging, formatting, or error transformation.

Exception handling promotes clean code by separating concerns: business logic throws errors, while filters handle presentation and logging. In real-world APIs, this ensures consistent error responses, better debugging, and improved security (e.g., hiding stack traces in production).

#### Key Concepts

- **Global Scope**: NestJS applies a default global filter. You can override it in `main.ts` with `app.useGlobalFilters(new CustomFilter())`.
- **Async Handling**: Exceptions in async code (e.g., promises) are automatically caught and propagated.
- **Error Propagation**: If an exception is thrown in a service, it bubbles up to the controller and then to the filter.

### Built-in Exceptions with Real-World Examples

NestJS offers several built-in exceptions from `@nestjs/common`, each tied to an HTTP status code. Here are the most commonly used ones, with real-world examples in an election management API (inspired by your previous entity descriptions, like managing admins, elections, and options).

1. **BadRequestException (HTTP 400)**:

   - **Purpose**: Thrown when client input is invalid (e.g., malformed request body, invalid parameters). It's the default for validation failures via `ValidationPipe`.
   - **Usage**: `throw new BadRequestException('Invalid input');`
   - **Real-World Example**: In a POST `/elections` endpoint to create an election, if the `start_date` is after `end_date`, throw this to reject the request.

     ```typescript
     // elections.controller.ts
     import { BadRequestException } from '@nestjs/common';

     @Post()
     createElection(@Body() dto: CreateElectionDto) {
       if (dto.startDate > dto.endDate) {
         throw new BadRequestException('Start date must be before end date');
       }
       // Proceed to create election
     }
     ```

     Response: `{ "statusCode": 400, "message": "Start date must be before end date", "error": "Bad Request" }`
     This prevents invalid elections from being created, common in scheduling apps.

2. **UnauthorizedException (HTTP 401)**:

   - **Purpose**: Indicates the client is not authenticated (e.g., missing or invalid token).
   - **Usage**: `throw new UnauthorizedException('Invalid credentials');`
   - **Real-World Example**: In a GET `/admin-users` endpoint to list admins, if the JWT token is missing or expired, throw this in an `@UseGuards(JwtAuthGuard)` protected route.

     ```typescript
     // admin-users.service.ts
     import { UnauthorizedException } from '@nestjs/common';

     async getAllAdmins(user: User) {
       if (!user.isAuthenticated) {
         throw new UnauthorizedException('Authentication required');
       }
       // Return admins
     }
     ```

     Response: `{ "statusCode": 401, "message": "Authentication required", "error": "Unauthorized" }`
     Common in auth flows, like requiring login to view election results.

3. **ForbiddenException (HTTP 403)**:

   - **Purpose**: The client is authenticated but lacks permission (e.g., role-based access denied).
   - **Usage**: `throw new ForbiddenException('Access denied');`
   - **Real-World Example**: In a PATCH `/elections/:id` endpoint to update an election, if the user is not the `created_by` admin, throw this.

     ```typescript
     // elections.service.ts
     import { ForbiddenException } from '@nestjs/common';

     async updateElection(id: number, dto: UpdateElectionDto, userId: number) {
       const election = await this.findOne(id);
       if (election.createdBy !== userId) {
         throw new ForbiddenException('You are not authorized to update this election');
       }
       // Update election
     }
     ```

     Response: `{ "statusCode": 403, "message": "You are not authorized to update this election", "error": "Forbidden" }`
     Essential for RBAC in apps like election management, where only creators can edit.

4. **NotFoundException (HTTP 404)**:

   - **Purpose**: Resource not found (e.g., invalid ID in GET request).
   - **Usage**: `throw new NotFoundException('Resource not found');`
   - **Real-World Example**: In a GET `/elections/:id` endpoint, if no election matches the ID, throw this.

     ```typescript
     // elections.service.ts
     import { NotFoundException } from '@nestjs/common';

     async findOne(id: number) {
       const election = await this.electionRepository.findById(id);
       if (!election) {
         throw new NotFoundException(`Election with ID ${id} not found`);
       }
       return election;
     }
     ```

     Response: `{ "statusCode": 404, "message": "Election with ID 123 not found", "error": "Not Found" }`
     Common in CRUD APIs, like fetching non-existent election options.

5. **InternalServerErrorException (HTTP 500)**:

   - **Purpose**: Unexpected server errors (e.g., database failures). Default for unhandled exceptions.
   - **Usage**: `throw new InternalServerErrorException('Server error');`
   - **Real-World Example**: In a POST `/election-options` endpoint, if a database insert fails due to a connection issue, catch and throw this.

     ```typescript
     // election-options.service.ts
     import { InternalServerErrorException } from '@nestjs/common';

     async createOption(dto: CreateElectionOptionDto) {
       try {
         // Database insert
         await this.optionRepository.save(dto);
       } catch (error) {
         throw new InternalServerErrorException('Failed to create option due to server error');
       }
     }
     ```

     Response: `{ "statusCode": 500, "message": "Failed to create option due to server error", "error": "Internal Server Error" }`
     Used for catching runtime errors in production, like third-party API failures in blockchain-integrated elections.

Other commonly used built-ins:

- **NotAcceptableException (406)**: For unacceptable content (e.g., unsupported file type in uploads).
- **RequestTimeoutException (408)**: For timed-out requests (e.g., long-running election vote processing).
- **ConflictException (409)**: For conflicts (e.g., duplicate election title).

### Custom Exceptions

Extend `HttpException` for domain-specific errors.

- **Example**: A `ElectionClosedException` for voting on closed elections.

  ```typescript
  // election-closed.exception.ts
  import { HttpException, HttpStatus } from "@nestjs/common";

  export class ElectionClosedException extends HttpException {
    constructor() {
      super("Election is closed for voting", HttpStatus.FORBIDDEN);
    }
  }
  ```

  Usage: `throw new ElectionClosedException();`
  This allows custom messages and codes while inheriting HTTP handling.

### Exception Filters

Filters intercept exceptions for custom handling (e.g., logging, formatting).

- **Example**: Global filter to log errors and hide details in production.

  ```typescript
  // http-exception.filter.ts
  import {
    ExceptionFilter,
    Catch,
    ArgumentsHost,
    HttpException,
    Logger,
  } from "@nestjs/common";

  @Catch(HttpException)
  export class HttpExceptionFilter implements ExceptionFilter {
    private readonly logger = new Logger(HttpExceptionFilter.name);

    catch(exception: HttpException, host: ArgumentsHost) {
      const ctx = host.switchToHttp();
      const response = ctx.getResponse();
      const request = ctx.getRequest();
      const status = exception.getStatus();

      this.logger.error(
        `HTTP Error: ${status} - ${exception.message}`,
        exception.stack
      );

      response.status(status).json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
        message: exception.message || "Internal server error",
      });
    }
  }
  ```

  Register globally in `main.ts`: `app.useGlobalFilters(new HttpExceptionFilter());`
  Real-world: Logs errors for debugging while sending user-friendly responses.

### Model Constraints in APIs (Validation) with Real-World Examples

Model constraints refer to validating API inputs (e.g., request bodies, queries) using DTOs (Data Transfer Objects) decorated with `class-validator` and enforced by `ValidationPipe`. This automatically throws `BadRequestException` on failures, ensuring data integrity before processing.

- **Setup**: Install `class-validator` and `class-transformer`. Use `ValidationPipe` globally:
  ```typescript
  // main.ts
  app.useGlobalPipes(
    new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true })
  );
  ```
  - `whitelist: true`: Strips unknown properties.
  - `forbidNonWhitelisted: true`: Throws errors on unknown properties.

Common decorators: `@IsString()`, `@IsNumber()`, `@IsEmail()`, `@MinLength(n)`, `@IsOptional()`, `@IsEnum()`, `@IsArray()`, `@ValidateNested()` for nested objects.

#### Real-World Examples in Election API

1. **Basic Validation (Create Admin User DTO)**:

   - Constraints: Username min 3 chars, password min 8, email valid.

     ```typescript
     // create-admin.dto.ts
     import { IsString, MinLength, IsEmail } from "class-validator";

     export class CreateAdminDto {
       @IsString()
       @MinLength(3, { message: "Username must be at least 3 characters" })
       username: string;

       @IsString()
       @MinLength(8, { message: "Password must be at least 8 characters" })
       password: string;

       @IsEmail({}, { message: "Invalid email format" })
       email: string;
     }
     ```

     Controller:

     ```typescript
     @Post('admin-users')
     createAdmin(@Body() dto: CreateAdminDto) {
       // dto is validated; proceed
     }
     ```

     Invalid Request (e.g., short password): Throws `BadRequestException` with `{ "statusCode": 400, "message": ["Password must be at least 8 characters"], "error": "Bad Request" }`.
     Real-world: Prevents weak passwords in admin creation.

2. **Nested/Complex Validation (Create Election with Options DTO)**:

   - Constraints: Title required, options array with at least 2 items, each option text min 1 char.

     ```typescript
     // create-election.dto.ts
     import {
       IsString,
       MinLength,
       IsArray,
       ArrayMinSize,
       ValidateNested,
     } from "class-validator";
     import { Type } from "class-transformer";

     class ElectionOptionDto {
       @IsString()
       @MinLength(1, { message: "Option text required" })
       optionText: string;
     }

     export class CreateElectionDto {
       @IsString()
       @MinLength(5, { message: "Title must be at least 5 characters" })
       title: string;

       @IsArray()
       @ArrayMinSize(2, { message: "At least 2 options required" })
       @ValidateNested({ each: true })
       @Type(() => ElectionOptionDto)
       options: ElectionOptionDto[];
     }
     ```

     Invalid Request (e.g., only 1 option): Throws `BadRequestException` with details on failed constraints.
     Real-world: Ensures elections have multiple valid choices, common in voting systems.

3. **Custom Validation (Unique Username Check)**:

   - Use a custom validator with `@ValidatorConstraint` to check database uniqueness.

     ```typescript
     // is-unique.validator.ts
     import {
       ValidatorConstraint,
       ValidatorConstraintInterface,
       ValidationArguments,
     } from "class-validator";
     import { Injectable } from "@nestjs/common";
     import { AdminUserService } from "./admin-user.service";

     @ValidatorConstraint({ async: true })
     @Injectable()
     export class IsUniqueUsernameConstraint
       implements ValidatorConstraintInterface
     {
       constructor(private adminUserService: AdminUserService) {}

       async validate(username: string, args: ValidationArguments) {
         const exists = await this.adminUserService.findByUsername(username);
         return !exists;
       }

       defaultMessage(args: ValidationArguments) {
         return "Username already exists";
       }
     }
     ```

     DTO Usage: `@Validate(IsUniqueUsernameConstraint) username: string;`
     Real-world: Prevents duplicate usernames during signup, integrating with services for async checks.

4. **Optional Fields and Enums (Update Election Status)**:

   - Constraints: Status optional but must be enum if provided.

     ```typescript
     // update-election.dto.ts
     import { IsOptional, IsEnum } from "class-validator";

     enum ElectionStatusEnum {
       Draft = "draft",
       Active = "active",
       Closed = "closed",
     }

     export class UpdateElectionDto {
       @IsOptional()
       @IsEnum(ElectionStatusEnum, { message: "Invalid status" })
       status?: ElectionStatusEnum;
     }
     ```

     Invalid Request (e.g., status: 'invalid'): Throws `BadRequestException`.
     Real-world: Allows partial updates while enforcing valid statuses in election management.

Validation integrates with exceptions: `ValidationPipe` throws `BadRequestException` on failures, which can be caught by filters for customization.
