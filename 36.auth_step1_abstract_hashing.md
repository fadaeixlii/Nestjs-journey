### Abstract Class and Interface for Authentication

**Purpose**: Use TypeScript abstract classes and interfaces to create a reusable, type-safe authentication system, with a specific `AbstractHashingService` for secure password hashing (e.g., for `AdminUser` in your election system).

**Why Use Them?**

- **Interfaces**: Ensure consistent method signatures (e.g., `hash`, `compare`).
- **Abstract Classes**: Provide shared logic (e.g., salt configuration) and enforce implementation.
- **Real-World Fit**: Securely hash admin passwords for managing `Election` entities, extensible for refresh tokens or API keys.

**Real-World Example**: An admin signs up to create an `Election`. The `AbstractHashingService` ensures the password is hashed securely (e.g., with `bcrypt`), and the `AuthService` uses it to manage authentication consistently.

---

### Steps for Abstract Class and Interface (Authentication and Hashing)

1. Define `HashingService` interface with `hash` and `compare` methods.
2. Create `AbstractHashingService` with abstract methods and shared config (e.g., salt rounds as `NaturalNumber`).
3. Implement `BcryptHashingService` using `bcrypt` for hashing.
4. Define `AuthService` interface for auth methods (`signUp`, `signIn`).
5. Create `AbstractAuthService` with shared logic (e.g., user lookup) and inject `HashingService`.
6. Implement `LocalAuthService` for username/password auth, using `BcryptHashingService`.
7. Use transactions for atomic user creation.
8. Validate inputs with `nestjs-zod` DTOs.
9. Throw custom exceptions (e.g., `UnauthorizedException`).
10. Test with mock `AdminUser` data.

---

### Code Examples

**HashingService Interface**

```typescript
import { NaturalNumber } from "./numbers/natural-number";

export interface HashingService {
  hash(data: string): Promise<string>;
  compare(data: string, hash: string): Promise<boolean>;
}
```

**AbstractHashingService**

```typescript
import { Injectable } from "@nestjs/common";
import { NaturalNumber } from "./numbers/natural-number";
import { HashingService } from "./hashing-service.interface";

@Injectable()
export abstract class AbstractHashingService implements HashingService {
  protected readonly saltRounds: NaturalNumber;

  constructor(saltRounds: NaturalNumber = 10 as NaturalNumber) {
    this.saltRounds = saltRounds;
  }

  abstract hash(data: string): Promise<string>;
  abstract compare(data: string, hash: string): Promise<boolean>;
}
```

**BcryptHashingService**

```typescript
import { Injectable } from "@nestjs/common";
import * as bcrypt from "bcrypt";
import { AbstractHashingService } from "./abstract-hashing.service";
import { NaturalNumber } from "./numbers/natural-number";
import { BadRequestException } from "@nestjs/common";

@Injectable()
export class BcryptHashingService extends AbstractHashingService {
  constructor(saltRounds: NaturalNumber = 10 as NaturalNumber) {
    super(saltRounds);
  }

  async hash(data: string): Promise<string> {
    if (!data) throw new BadRequestException("Data to hash cannot be empty");
    const salt = await bcrypt.genSalt(this.saltRounds);
    return bcrypt.hash(data, salt);
  }

  async compare(data: string, hash: string): Promise<boolean> {
    if (!data || !hash) throw new BadRequestException("Invalid data or hash");
    return bcrypt.compare(data, hash);
  }
}
```

**AuthService Interface**

```typescript
import { Id } from "./id-maker";

export interface AuthService {
  signUp(
    dto: SignUpDto
  ): Promise<{ accessToken: string; refreshToken: string }>;
  signIn(
    dto: SignInDto
  ): Promise<{ accessToken: string; refreshToken: string }>;
  validateUser(userId: Id): Promise<AdminUser | null>;
}
```

**AbstractAuthService**

```typescript
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { DataSource, Repository } from "typeorm";
import { InjectRepository } from "@nestjs/typeorm";
import { AuthService } from "./auth-service.interface";
import { AdminUser } from "./admin-user.entity";
import { HashingService } from "./hashing-service.interface";
import { JwtService } from "@nestjs/jwt";
import { Id } from "./id-maker";

@Injectable()
export abstract class AbstractAuthService implements AuthService {
  constructor(
    protected readonly dataSource: DataSource,
    @InjectRepository(AdminUser)
    protected readonly adminUserRepository: Repository<AdminUser>,
    protected readonly hashingService: HashingService,
    protected readonly jwtService: JwtService
  ) {}

  async validateUser(userId: Id): Promise<AdminUser | null> {
    const user = await this.adminUserRepository.findOne({
      where: { id: userId },
    });
    if (!user) throw new UnauthorizedException("User not found");
    return user;
  }

  abstract signUp(
    dto: SignUpDto
  ): Promise<{ accessToken: string; refreshToken: string }>;
  abstract signIn(
    dto: SignInDto
  ): Promise<{ accessToken: string; refreshToken: string }>;
}
```

**SignUpDto (nestjs-zod)**

```typescript
import { z } from "zod";
import { createZodDto } from "nestjs-zod";

const SignUpSchema = z.object({
  username: z.string().min(3),
  password: z.string().min(8),
  email: z.string().email(),
});
export class SignUpDto extends createZodDto(SignUpSchema) {}
```

**LocalAuthService**

```typescript
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { DataSource, Repository } from "typeorm";
import { InjectRepository } from "@nestjs/typeorm";
import { AbstractAuthService } from "./abstract-auth.service";
import { AdminUser } from "./admin-user.entity";
import { HashingService } from "./hashing-service.interface";
import { JwtService } from "@nestjs/jwt";
import { SignUpDto } from "./sign-up.dto";
import { SignInDto } from "./sign-in.dto";

@Injectable()
export class LocalAuthService extends AbstractAuthService {
  constructor(
    dataSource: DataSource,
    @InjectRepository(AdminUser) adminUserRepository: Repository<AdminUser>,
    hashingService: HashingService,
    jwtService: JwtService
  ) {
    super(dataSource, adminUserRepository, hashingService, jwtService);
  }

  async signUp(
    dto: SignUpDto
  ): Promise<{ accessToken: string; refreshToken: string }> {
    return this.dataSource.transaction(async (manager) => {
      const user = new AdminUser();
      user.username = dto.username;
      user.email = dto.email;
      user.password = await this.hashingService.hash(dto.password);
      await manager.save(AdminUser, user);

      const payload = { userId: user.id };
      const accessToken = this.jwtService.sign(payload, { expiresIn: "15m" });
      const refreshToken = this.jwtService.sign(payload, { expiresIn: "7d" });
      return { accessToken, refreshToken };
    });
  }

  async signIn(
    dto: SignInDto
  ): Promise<{ accessToken: string; refreshToken: string }> {
    const user = await this.adminUserRepository.findOne({
      where: { username: dto.username },
    });
    if (
      !user ||
      !(await this.hashingService.compare(dto.password, user.password))
    ) {
      throw new UnauthorizedException("Invalid credentials");
    }

    const payload = { userId: user.id };
    const accessToken = this.jwtService.sign(payload, { expiresIn: "15m" });
    const refreshToken = this.jwtService.sign(payload, { expiresIn: "7d" });
    return { accessToken, refreshToken };
  }
}
```

---

### Short Explanation

- **HashingService**:

  - **Interface**: Defines `hash` and `compare` for consistent hashing across algorithms.
  - **Abstract Class**: Configures `saltRounds` (as `NaturalNumber`) and enforces method implementation.
  - **Bcrypt Implementation**: Uses `bcrypt` to hash/verify passwords securely.
  - **Use Case**: Hashes `AdminUser` passwords during signup, verifies during login.

- **AuthService**:

  - **Interface**: Ensures `signUp`, `signIn`, `validateUser` have consistent signatures.
  - **Abstract Class**: Provides shared logic (e.g., user lookup, JWT signing) and injects `HashingService`.
  - **Local Implementation**: Handles username/password auth with transactions and `BcryptHashingService`.

- **Real-World Example**: An admin signs up to manage an `Election`. `LocalAuthService` uses `BcryptHashingService` to hash the password, saves the `AdminUser` in a transaction, and generates JWTs. The abstract classes ensure reusability for other strategies (e.g., OAuth).

- **Benefits**:
  - **Type Safety**: Uses `Id` and `NaturalNumber` for IDs and salt rounds.
  - **Reusability**: Swap `BcryptHashingService` for another algorithm without changing `AuthService`.
  - **Extensibility**: Add OAuth or API key auth by extending `AbstractAuthService`.
  - **Integration**: Works with `Paginate` for listing users and transactions for atomicity.
