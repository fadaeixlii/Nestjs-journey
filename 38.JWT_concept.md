**What is JWT?**  
JSON Web Token (JWT) is a compact, self-contained token for secure data exchange between parties. It consists of three parts: **Header**, **Payload**, and **Signature**, encoded in Base64 and separated by dots (`header.payload.signature`). JWTs are used for authentication and authorization, typically in APIs, by verifying user identity without server-side session storage.

**How It Works**:

1. **Header**: Contains metadata (e.g., algorithm like HS256).
2. **Payload**: Holds claims (e.g., user ID, role, expiration).
3. **Signature**: Ensures integrity, created by signing `header.payload` with a secret key.
4. Client sends JWT in requests (e.g., `Authorization: Bearer <token>`).
5. Server verifies the signature and checks claims (e.g., expiration).

**Key Features**:

- **Stateless**: No server-side storage; token contains all needed info.
- **Secure**: Signature prevents tampering; HTTPS encrypts transmission.
- **Compact**: JSON format, Base64-encoded, lightweight for APIs.

**Why Use JWT?**

- Scalable for stateless APIs (e.g., microservices).
- Securely authenticates users across domains.
- Supports role-based access (e.g., admin vs. voter).

**Real-World Examples in Election System**:

1. **Admin Login**: An admin logs into your election system to manage `Election` entities. The server issues a JWT with `{ userId: Id, role: 'admin' }`. The admin uses this token to access `POST /elections`, verified by a `JwtAuthGuard`.
2. **Voter Authentication**: A voter logs in via email/password to vote on `ElectionOption`. The server returns a JWT with `{ userId: Id, role: 'voter' }`, used to authorize `POST /votes`.
3. **API Integration**: A third-party app accesses election results via `GET /elections/results`. A JWT with `{ appId: Id, scope: 'read:results' }` ensures only authorized apps access data.

---

### Steps for Implementing JWT in NestJS

1. Install `@nestjs/jwt` and `@nestjs/passport`.
2. Configure `JwtModule` with a secret (from `@nestjs/config`) and expiration (e.g., `15m`).
3. Define a `JwtPayload` interface (e.g., `{ userId: Id, role: string }`).
4. In `AuthService`, implement `signIn` to generate JWT with `JwtService.sign`.
5. Create a `JwtAuthGuard` using `passport-jwt` to protect endpoints.
6. Validate JWT payload by fetching `AdminUser` from repository.
7. Throw `UnauthorizedException` for invalid/expired tokens.
8. Use `nestjs-zod` for `SignInDto` validation.
9. Test with mock users to verify token generation and validation.

---

### Example Code (Inline)

**JwtPayload Interface**

```typescript
import { Id } from "./id-maker";
export interface JwtPayload {
  userId: Id;
  role: string;
}
```

**JwtModule Configuration**

```typescript
import { Module } from "@nestjs/common";
import { JwtModule } from "@nestjs/jwt";
import { ConfigModule, ConfigService } from "@nestjs/config";
@Module({
  imports: [
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>("JWT_SECRET"),
        signOptions: { expiresIn: "15m" },
      }),
      inject: [ConfigService],
    }),
  ],
})
export class AuthModule {}
```

**AuthService with JWT**

```typescript
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { JwtService } from "@nestjs/jwt";
import { AdminUser } from "./admin-user.entity";
import { SignInDto } from "./sign-in.dto";
import { HashingService } from "./hashing-service.interface";
import { JwtPayload } from "./jwt-payload.interface";
@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(AdminUser)
    private adminUserRepository: Repository<AdminUser>,
    private jwtService: JwtService,
    private hashingService: HashingService
  ) {}
  async signIn(dto: SignInDto): Promise<{ accessToken: string }> {
    const user = await this.adminUserRepository.findOne({
      where: { username: dto.username },
    });
    if (
      !user ||
      !(await this.hashingService.compare(dto.password, user.password))
    ) {
      throw new UnauthorizedException("Invalid credentials");
    }
    const payload: JwtPayload = { userId: user.id, role: user.role };
    const accessToken = this.jwtService.sign(payload);
    return { accessToken };
  }
}
```

**JwtAuthGuard**

```typescript
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";
@Injectable()
export class JwtAuthGuard extends AuthGuard("jwt") {
  handleRequest(err, user) {
    if (err || !user) throw err || new UnauthorizedException("Invalid token");
    return user;
  }
}
```

**Protected Endpoint**

```typescript
import { Controller, Get, UseGuards } from "@nestjs/common";
import { JwtAuthGuard } from "./jwt-auth.guard";
@Controller("elections")
export class ElectionsController {
  @Get()
  @UseGuards(JwtAuthGuard)
  async getElections() {
    return { message: "Protected election data" };
  }
}
```

---

### Short Explanation

- **JWT Structure**: Encodes user data (e.g., `userId`, `role`) in a token, signed with a secret to prevent tampering.
- **Usage**: Client sends JWT in `Authorization` header; server verifies it to grant access.
- **Election System Fit**: Secures admin access to `Election` management and voter access to `ElectionOption` voting.
- **Benefits**: Stateless, scalable, secure with short expiration (e.g., 15m).
- **Integration**: Uses `Id` from `IdMaker` for `userId`, `nestjs-zod` for DTOs, and transactions for user operations.
