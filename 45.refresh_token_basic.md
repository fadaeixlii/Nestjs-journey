## üîë 1. What is a Refresh Token?

- A **JWT Access Token** (short-lived, e.g. 15 minutes) ‚Üí used for API requests.
- A **Refresh Token** (long-lived, e.g. 7 days or 30 days) ‚Üí used **only** to obtain new Access Tokens when they expire.

üëâ Idea: **Never keep users logged out just because their Access Token expired**, but also **don‚Äôt allow unlimited lifetime tokens**.

---

## üîê 2. Why Use Refresh Tokens?

- **Security** ‚Üí Access tokens expire quickly, so if stolen, damage is limited.
- **Convenience** ‚Üí User doesn‚Äôt need to log in every 15 minutes.
- **Revocation** ‚Üí You can revoke refresh tokens (logout, password change, device lost).

---

## üõë 3. Where to Store Tokens

- **Access Token** ‚Üí usually stored in memory (frontend app state).
- **Refresh Token** ‚Üí

  - Option 1: **HTTP-only Secure Cookie** (best for browsers).
  - Option 2: **Database** (store token with user/device id, can revoke individually).
  - Option 3: **LocalStorage** (not recommended ‚Äî XSS risk).

---

## üîÑ 4. Token Rotation (Best Practice)

Every time you refresh:

1. Issue a **new Access Token**.
2. Issue a **new Refresh Token**.
3. Invalidate the old Refresh Token (rotation).

   - Prevents ‚ÄúReplay Attacks‚Äù (stolen refresh token used multiple times).

---

## üèóÔ∏è 5. Real World Example (NestJS)

### Entities

`user.entity.ts`

```ts
import { Entity, Column, PrimaryGeneratedColumn, OneToMany } from "typeorm";
import { RefreshToken } from "./refresh-token.entity";

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true })
  email: string;

  @Column()
  passwordHash: string;

  @OneToMany(() => RefreshToken, (rt) => rt.user)
  refreshTokens: RefreshToken[];
}
```

`refresh-token.entity.ts`

```ts
import { Entity, Column, PrimaryGeneratedColumn, ManyToOne } from "typeorm";
import { User } from "./user.entity";

@Entity()
export class RefreshToken {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  token: string; // hashed version of refresh token

  @Column()
  expiresAt: Date;

  @Column({ default: false })
  revoked: boolean;

  @ManyToOne(() => User, (user) => user.refreshTokens, { onDelete: "CASCADE" })
  user: User;
}
```

---

### Auth Service

`auth.service.ts`

```ts
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";
import { Repository } from "typeorm";
import { InjectRepository } from "@nestjs/typeorm";
import { RefreshToken } from "./refresh-token.entity";
import { User } from "./user.entity";
import * as bcrypt from "bcrypt";
import { randomBytes } from "crypto";

@Injectable()
export class AuthService {
  constructor(
    private jwt: JwtService,
    @InjectRepository(User) private users: Repository<User>,
    @InjectRepository(RefreshToken)
    private refreshTokens: Repository<RefreshToken>
  ) {}

  async generateTokens(user: User) {
    const payload = { sub: user.id, email: user.email, roles: ["user"] };

    const accessToken = this.jwt.sign(payload, { expiresIn: "15m" });

    // refresh token as random string (not JWT, safer)
    const refreshTokenRaw = randomBytes(64).toString("hex");
    const refreshTokenHash = await bcrypt.hash(refreshTokenRaw, 10);

    const refreshToken = this.refreshTokens.create({
      token: refreshTokenHash,
      expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 7), // 7 days
      user,
    });
    await this.refreshTokens.save(refreshToken);

    return {
      accessToken,
      refreshToken: refreshTokenRaw, // raw token goes to client
    };
  }

  async refreshToken(userId: number, token: string) {
    const user = await this.users.findOne({
      where: { id: userId },
      relations: ["refreshTokens"],
    });
    if (!user) throw new UnauthorizedException();

    const validToken = user.refreshTokens.find(
      (t) =>
        !t.revoked &&
        t.expiresAt > new Date() &&
        bcrypt.compareSync(token, t.token)
    );
    if (!validToken) throw new UnauthorizedException("Invalid refresh token");

    // Invalidate old token
    validToken.revoked = true;
    await this.refreshTokens.save(validToken);

    return this.generateTokens(user);
  }
}
```

---

### Controller

`auth.controller.ts`

```ts
import {
  Controller,
  Post,
  Body,
  Req,
  UnauthorizedException,
} from "@nestjs/common";
import { AuthService } from "./auth.service";
import { CurrentUser } from "./auth/current-user.decorator";

@Controller("auth")
export class AuthController {
  constructor(private auth: AuthService) {}

  @Post("login")
  async login(@Body() body: { email: string; password: string }) {
    // pseudo-check password
    const user = await this.auth.validateUser(body.email, body.password);
    if (!user) throw new UnauthorizedException();

    return this.auth.generateTokens(user);
  }

  @Post("refresh")
  async refresh(@Body() body: { userId: number; refreshToken: string }) {
    return this.auth.refreshToken(body.userId, body.refreshToken);
  }

  @Post("logout")
  async logout(
    @CurrentUser() user: any,
    @Body() body: { refreshToken: string }
  ) {
    await this.auth.revokeToken(user.sub, body.refreshToken);
    return { msg: "Logged out" };
  }
}
```

---

## üåç 6. Real World Use Cases

1. **Banking App**

   - Access Token ‚Üí 5 min.
   - Refresh Token ‚Üí 24h.
   - If user closes browser, still logged in until refresh expires.

2. **E-commerce**

   - Keep cart & session alive.
   - Use **refresh rotation** so stolen tokens can‚Äôt be reused.

3. **Mobile App**

   - Store refresh token in secure storage (Keychain/Keystore).
   - Long expiry (30d).

4. **Admin Panel**

   - Shorter refresh token (maybe 1 day).
   - Allow logout from all devices (revoke all refresh tokens for that user).

---

## ‚ö° Tips & Best Practices

- üîí Always hash refresh tokens in DB.
- üîÑ Use rotation ‚Üí issue new refresh token each time.
- üóëÔ∏è On logout ‚Üí revoke refresh token.
- ‚öîÔ∏è Detect reuse (if old refresh token used twice ‚Üí compromise alert).
- ‚è≥ Keep access token short-lived.
