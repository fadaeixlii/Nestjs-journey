# 1Ô∏è‚É£ Define Auth Types (Enum)

`auth/auth.types.ts`

```ts
export enum AuthType {
  Public = "public",
  User = "user",
  Admin = "admin",
}
```

---

# 2Ô∏è‚É£ Auth Metadata Decorator

We‚Äôll create a single decorator `@Auth()` that stores metadata on the route.

`auth/decorators/auth.decorator.ts`

```ts
import { SetMetadata } from "@nestjs/common";
import { AuthType } from "../auth.types";

export const AUTH_TYPE_KEY = "auth_type";

// Usage: @Auth(AuthType.Admin)
export const Auth = (type: AuthType = AuthType.User) =>
  SetMetadata(AUTH_TYPE_KEY, type);
```

---

# 3Ô∏è‚É£ Public, User, Admin Shortcuts (Optional)

For cleaner syntax:

```ts
import { Auth, AUTH_TYPE_KEY } from "./auth.decorator";
import { AuthType } from "../auth.types";

export const Public = () => Auth(AuthType.Public);
export const User = () => Auth(AuthType.User);
export const Admin = () => Auth(AuthType.Admin);
```

---

# 4Ô∏è‚É£ Global Auth Guard

Instead of applying `@UseGuards()` everywhere, we use a **global guard** that:

- Reads `@Auth()` metadata.
- By default ‚Üí requires user JWT.
- If `Public` ‚Üí skips JWT.
- If `Admin` ‚Üí requires JWT + admin role.

`auth/guards/auth.guard.ts`

```ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
  ForbiddenException,
  Reflector,
} from "@nestjs/common";
import { AuthGuard as PassportAuthGuard } from "@nestjs/passport";
import { AuthType } from "../auth.types";
import { AUTH_TYPE_KEY } from "../decorators/auth.decorator";

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const authType =
      this.reflector.getAllAndOverride<AuthType>(AUTH_TYPE_KEY, [
        context.getHandler(),
        context.getClass(),
      ]) ?? AuthType.User; // default is User auth

    const request = context.switchToHttp().getRequest();

    // Public ‚Üí allow without checks
    if (authType === AuthType.Public) return true;

    // Otherwise ‚Üí check JWT
    const passportAuthGuard = new (PassportAuthGuard("jwt"))();
    const canActivate = await passportAuthGuard.canActivate(context);
    if (!canActivate) throw new UnauthorizedException();

    // At this point, JWT is valid
    const user = request.user;

    if (authType === AuthType.Admin && user.role !== "admin") {
      throw new ForbiddenException("Admins only");
    }

    return true;
  }
}
```

---

# 5Ô∏è‚É£ Provide Guard Globally

In your `app.module.ts`:

```ts
import { APP_GUARD } from "@nestjs/core";
import { AuthGuard } from "./auth/guards/auth.guard";

@Module({
  providers: [
    {
      provide: APP_GUARD,
      useClass: AuthGuard, // üî• global guard
    },
  ],
})
export class AppModule {}
```

Now, all routes are protected by default (`AuthType.User`).

---

# 6Ô∏è‚É£ CurrentUser Decorator (JWT Payload Access)

`auth/decorators/current-user.decorator.ts`

```ts
import { createParamDecorator, ExecutionContext } from "@nestjs/common";

export const CurrentUser = createParamDecorator(
  (data: keyof any, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;
    return data ? user?.[data] : user;
  }
);
```

---

# 7Ô∏è‚É£ Example Usage

`users.controller.ts`

```ts
import { Controller, Get } from "@nestjs/common";
import { CurrentUser } from "../auth/decorators/current-user.decorator";
import { Auth, Public, Admin } from "../auth/decorators/auth.decorator";
import { AuthType } from "../auth/auth.types";

@Controller("users")
export class UsersController {
  // Public route
  @Get("welcome")
  @Public()
  getWelcome() {
    return { message: "Anyone can access this" };
  }

  // Default (requires User JWT)
  @Get("me")
  getMe(@CurrentUser() user: any) {
    return { message: "Current user", user };
  }

  // Admin-only route
  @Get("admin")
  @Admin()
  getAdminData(@CurrentUser() user: any) {
    return { message: "Hello Admin", user };
  }

  // Alternative syntax using @Auth()
  @Get("custom")
  @Auth(AuthType.Admin)
  getCustomAdmin(@CurrentUser("email") email: string) {
    return { message: "Admin email", email };
  }
}
```

---

# 8Ô∏è‚É£ Example JWT Payload

```json
{
  "sub": 42,
  "email": "admin@example.com",
  "role": "admin",
  "iat": 1715800000,
  "exp": 1716400000
}
```

---

# üßë‚Äçüíª Real-World Flow

1. User signs in ‚Üí receives JWT `{ sub, email, role }`.
2. All APIs are protected (need JWT).
3. Public endpoints must be explicitly marked `@Public()`.
4. Admin endpoints ‚Üí `@Admin()` or `@Auth(AuthType.Admin)`.
5. Extract user payload with `@CurrentUser()`.

---

# ‚úÖ Best Practices

- ‚úÖ Make **auth guard global** ‚Üí secure by default.
- ‚úÖ Use enums (`AuthType`) instead of strings.
- ‚úÖ Always enforce `ForbiddenException` for role-based denial.
- ‚úÖ Keep JWT **minimal** (sub, email, role, maybe permissions).
- ‚úÖ Use `@CurrentUser()` decorator instead of `req.user`.
