## ‚úÖ What is Cascade in TypeORM?

**Cascade** means that **changes to a parent entity** will also be **automatically applied to its related (child) entities**.

### üß† Think of it like this:

> If you `save` or `remove` a parent entity, and it has children, those children will also be `saved`, `updated`, or `deleted` **automatically**, depending on the **cascade options** you enable.

---

## üîß How to Use Cascade

### Example: One-to-Many (User ‚Üí Posts)

```ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @OneToMany(() => Post, (post) => post.author, {
    cascade: true, // or ['insert', 'update']
    eager: true,
  })
  posts: Post[];
}
```

```ts
@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @ManyToOne(() => User, (user) => user.posts)
  author: User;
}
```

### Now:

```ts
const user = new User();
user.name = "Ali";

const post = new Post();
post.title = "My Post";
post.author = user;

user.posts = [post];

await this.userRepo.save(user); // üëà This saves both user & post!
```

---

## üîÅ Cascade Options

| Option        | Meaning                                        |
| ------------- | ---------------------------------------------- |
| `insert`      | Insert related entity when saving the parent   |
| `update`      | Update related entity when saving the parent   |
| `remove`      | Remove related entity when removing the parent |
| `soft-remove` | Apply soft-delete to related entity            |
| `recover`     | Recover a soft-deleted related entity          |
| `true`        | Apply all of the above                         |

```ts
cascade: ["insert", "update"];
```

---

## ‚ùå Why Can't I Update Relational Entities?

You might do something like:

```ts
await userRepository.save({
  id: 1,
  posts: [{ id: 5, title: "Updated Title" }],
});
```

And it does **NOT update** the `post`.

### üîç Why?

1. TypeORM does **not know** that you want to update the post unless:

   - It is attached as a fully-managed entity
   - You explicitly set `cascade: ['update']` on the relation
   - You fetched it via `.find({ relations: ['posts'] })`

2. If you're passing a **plain object**, it's not treated as an entity with behavior.

---

## üõ†Ô∏è Solutions

### ‚úÖ Recommended Way (Fetch ‚Üí Modify ‚Üí Save)

```ts
const user = await userRepo.findOne({
  where: { id: 1 },
  relations: ["posts"],
});

user.posts[0].title = "Updated Title";

await userRepo.save(user); // This works if cascade: ['update'] is enabled
```

---

### ‚úÖ Explicitly Save Related Entity

```ts
await postRepo.save({
  id: 5,
  title: "Updated Title",
});
```

---

## üåç Real-World Examples

### üõí E-commerce App

- `Order` has many `OrderItem`s
- When saving a new order, you want to save all items as well.

```ts
@OneToMany(() => OrderItem, (item) => item.order, {
  cascade: ['insert'],
})
items: OrderItem[];
```

---

### üß† User with Profile

```ts
@OneToOne(() => Profile, (profile) => profile.user, {
  cascade: true, // save user + profile together
})
@JoinColumn()
profile: Profile;
```

```ts
const user = new User();
user.name = "Zahra";
user.profile = new Profile();
user.profile.bio = "Full-stack dev";

await userRepo.save(user);
```

---

## ‚ö†Ô∏è Common Mistakes

| Mistake                            | Fix                                                                       |
| ---------------------------------- | ------------------------------------------------------------------------- |
| Cascade not working                | Ensure related entities are passed as class instances (not plain objects) |
| Cascade not enabled                | Add `cascade: ['insert', 'update']` or `true` on relation                 |
| Forgetting `relations` in find     | Must use `.find({ relations: [...] })` to load child entities             |
| Updating relation without fetching | Fetch parent with relation first or save directly via child repo          |
| Lazy loading with cascade          | Avoid using `Promise<>` lazy load with cascade, prefer eager loading      |

---

## üí° Best Practices

- ‚úÖ Use `cascade` for deeply nested inserts (like user + profile or order + items)
- ‚ùå Avoid cascade for deletions in complex systems (use manual deletion logic)
- ‚úÖ Always validate nested data before saving (use class-validator)
- ‚úÖ Use `eager` if you always want the relation loaded (careful with large datasets)
- ‚ùå Don‚Äôt mutate nested objects without loading them from DB first
