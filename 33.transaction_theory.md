### What is a Database Transaction?

A **database transaction** is a sequence of database operations (e.g., `INSERT`, `UPDATE`, `DELETE`) that are executed as a single, atomic unit. Transactions ensure that either **all operations succeed** or **none are applied**, maintaining data consistency and integrity. They follow the **ACID** principles:

- **Atomicity**: All operations in a transaction are completed successfully, or none are applied.
- **Consistency**: The database remains in a valid state before and after the transaction.
- **Isolation**: Transactions are isolated from each other, preventing interference.
- **Durability**: Once a transaction is committed, changes are permanently saved.

In NestJS, transactions are commonly used with an ORM like **TypeORM** or **Prisma** to manage database operations. They are critical when multiple entities are involved to ensure data consistency and handle errors via automatic rollback.

---

### Why Use Transactions?

Transactions are used to:

1. **Ensure Data Consistency Across Multiple Entities**: When operations span multiple tables (e.g., creating an election and its options), transactions prevent partial updates.
2. **Assure Data Integrity**: Validate that all operations meet constraints (e.g., foreign keys, unique constraints) before committing.
3. **Automatic Rollback on Failure**: If any operation fails, the transaction rolls back all changes, preventing inconsistent data.
4. **Handle Concurrent Operations**: Isolation ensures concurrent transactions don’t corrupt data.

Without transactions, partial failures could leave the database in an invalid state (e.g., an election created without its options or vice versa).

---

### Key Features of Transactions

- **Atomicity**: Ensures all operations succeed or fail together.
- **Rollback**: Automatically reverts changes if an error occurs.
- **Commit**: Applies changes only if all operations succeed.
- **Isolation Levels**: Control how transactions interact (e.g., `SERIALIZABLE` for strict isolation, `READ_COMMITTED` for performance).

In NestJS with TypeORM, transactions are managed using the `DataSource` or `EntityManager` with a `transaction` method.

---

### Real-World Examples in Election Management System

Let’s apply transactions to your election system, which involves `AdminUser`, `Election`, and `ElectionOption` entities. We’ll use TypeORM in a NestJS application to demonstrate creating an election with options, updating vote counts, and handling errors with rollback. Each example shows multiple entities, assured data, and auto-rollback.

#### Prerequisites

Assume the following entity definitions (simplified from your previous questions):

```typescript
// admin-user.entity.ts
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity("admin_users")
export class AdminUser {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  username: string;
}

// election.entity.ts
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity("elections")
export class Election {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @Column()
  createdBy: number; // Foreign key to AdminUser.id
}

// election-option.entity.ts
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity("election_options")
export class ElectionOption {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  electionId: number; // Foreign key to Election.id

  @Column()
  optionText: string;

  @Column({ default: 0 })
  voteCount: number;
}
```

#### Example 1: Creating an Election with Options (Multiple Entities)

**Scenario**: An admin creates an election with multiple options (e.g., candidates). All operations must succeed, or none should be applied to avoid orphaned data.

**Why Transaction?**

- Involves two entities: `Election` and `ElectionOption`.
- Ensures the election and its options are created together.
- Rolls back if any option fails (e.g., due to validation or database constraints).

**Code**:

```typescript
// elections.service.ts
import { Injectable, BadRequestException } from "@nestjs/common";
import { DataSource } from "typeorm";
import { Election } from "./election.entity";
import { ElectionOption } from "./election-option.entity";

@Injectable()
export class ElectionsService {
  constructor(private dataSource: DataSource) {}

  async createElection(dto: CreateElectionDto) {
    // Validate input
    if (dto.options.length < 2) {
      throw new BadRequestException("At least 2 options required");
    }

    // Start transaction
    return await this.dataSource.transaction(async (manager) => {
      // Create election
      const election = new Election();
      election.title = dto.title;
      election.createdBy = dto.createdBy;
      const savedElection = await manager.save(Election, election);

      // Create options
      const options = dto.options.map((opt) => {
        const option = new ElectionOption();
        option.electionId = savedElection.id;
        option.optionText = opt.optionText;
        return option;
      });

      // Simulate failure for demo (e.g., duplicate option text)
      if (options.some((opt) => opt.optionText === "InvalidOption")) {
        throw new BadRequestException("Invalid option text");
      }

      await manager.save(ElectionOption, options);

      return { election: savedElection, options };
    });
  }
}

// create-election.dto.ts
import {
  IsString,
  MinLength,
  IsNumber,
  IsArray,
  ArrayMinSize,
} from "class-validator";

export class CreateElectionDto {
  @IsString()
  @MinLength(5)
  title: string;

  @IsNumber()
  createdBy: number;

  @IsArray()
  @ArrayMinSize(2)
  options: { optionText: string }[];
}
```

**Controller**:

```typescript
// elections.controller.ts
import { Controller, Post, Body } from "@nestjs/common";
import { ElectionsService } from "./elections.service";
import { CreateElectionDto } from "./create-election.dto";

@Controller("elections")
export class ElectionsController {
  constructor(private electionsService: ElectionsService) {}

  @Post()
  async create(@Body() dto: CreateElectionDto) {
    return this.electionsService.createElection(dto);
  }
}
```

**Explanation**:

- **Multiple Entities**: Creates one `Election` and multiple `ElectionOption` records.
- **Assured Data**: The transaction ensures the election and all options are saved together, maintaining foreign key integrity (`electionId` in `ElectionOption`).
- **Auto Rollback**: If any operation fails (e.g., invalid option text), the transaction rolls back:
  - No `Election` or `ElectionOption` records are saved.
  - Example: If `options` contains "InvalidOption", the `BadRequestException` triggers rollback.
- **Response on Success**: `{ election: { id: 1, title: 'Board Election 2025', createdBy: 1 }, options: [{ id: 1, electionId: 1, optionText: 'Candidate A' }, ...] }`
- **Response on Failure**: `{ statusCode: 400, message: 'Invalid option text', error: 'Bad Request' }`

**Real-World Use**: Ensures elections are created with valid options (e.g., at least two candidates), preventing incomplete setups in voting systems.

#### Example 2: Voting in an Election (Updating Multiple Entities)

**Scenario**: A voter submits a vote, incrementing the `voteCount` of an `ElectionOption` and updating the `Election`’s total votes (assume a `totalVotes` field). Both updates must succeed to keep counts consistent.

**Why Transaction?**

- Updates two entities: `ElectionOption` and `Election`.
- Ensures vote counts are consistent (e.g., sum of option votes matches election total).
- Rolls back if either update fails (e.g., database timeout).

**Code**:

```typescript
// elections.service.ts
import {
  Injectable,
  NotFoundException,
  ForbiddenException,
} from "@nestjs/common";
import { DataSource } from "typeorm";
import { Election } from "./election.entity";
import { ElectionOption } from "./election-option.entity";

@Injectable()
export class ElectionsService {
  constructor(private dataSource: DataSource) {}

  async castVote(electionId: number, optionId: number) {
    return await this.dataSource.transaction(async (manager) => {
      // Find election and option
      const election = await manager.findOne(Election, {
        where: { id: electionId },
      });
      if (!election) {
        throw new NotFoundException(`Election with ID ${electionId} not found`);
      }
      if (election.status !== "active") {
        throw new ForbiddenException("Election is not active");
      }

      const option = await manager.findOne(ElectionOption, {
        where: { id: optionId, electionId },
      });
      if (!option) {
        throw new NotFoundException(`Option with ID ${optionId} not found`);
      }

      // Update vote counts
      option.voteCount += 1;
      election.totalVotes = (election.totalVotes || 0) + 1;

      // Simulate failure for demo (e.g., database constraint)
      if (option.voteCount > 1000) {
        throw new ForbiddenException("Vote limit exceeded");
      }

      await manager.save(ElectionOption, option);
      await manager.save(Election, election);

      return { election, option };
    });
  }
}
```

**Explanation**:

- **Multiple Entities**: Updates `voteCount` in `ElectionOption` and `totalVotes` in `Election`.
- **Assured Data**: The transaction ensures both updates are applied or none, keeping vote counts consistent.
- **Auto Rollback**: If the vote limit is exceeded or a database error occurs, both updates are rolled back.
- **Real-World Use**: Prevents vote count discrepancies in election systems, critical for auditability and integrity.

#### Example 3: Transferring Admin Rights (Atomic Operation)

**Scenario**: Transfer ownership of an election from one admin to another, updating `Election.createdBy` and logging the action in a hypothetical `AdminLog` entity.

**Why Transaction?**

- Involves two entities: `Election` and `AdminLog`.
- Ensures the ownership update and log entry are both committed or neither.
- Rolls back if the new admin doesn’t exist or logging fails.

**Code**:

```typescript
// admin-log.entity.ts
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity("admin_logs")
export class AdminLog {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  adminId: number;

  @Column()
  action: string;

  @Column()
  timestamp: Date;
}

// elections.service.ts
import { Injectable, NotFoundException } from "@nestjs/common";
import { DataSource } from "typeorm";
import { Election } from "./election.entity";
import { AdminLog } from "./admin-log.entity";
import { AdminUser } from "./admin-user.entity";

@Injectable()
export class ElectionsService {
  constructor(private dataSource: DataSource) {}

  async transferOwnership(electionId: number, newAdminId: number) {
    return await this.dataSource.transaction(async (manager) => {
      // Verify election and admin
      const election = await manager.findOne(Election, {
        where: { id: electionId },
      });
      if (!election) {
        throw new NotFoundException(`Election with ID ${electionId} not found`);
      }

      const newAdmin = await manager.findOne(AdminUser, {
        where: { id: newAdminId },
      });
      if (!newAdmin) {
        throw new NotFoundException(`Admin with ID ${newAdminId} not found`);
      }

      // Update election ownership
      election.createdBy = newAdminId;

      // Create log entry
      const log = new AdminLog();
      log.adminId = newAdminId;
      log.action = `Transferred ownership of election ${electionId}`;
      log.timestamp = new Date();

      // Simulate failure for demo
      if (newAdminId === 999) {
        throw new Error("Simulated database failure");
      }

      await manager.save(Election, election);
      await manager.save(AdminLog, log);

      return { election, log };
    });
  }
}
```

**Explanation**:

- **Multiple Entities**: Updates `Election.createdBy` and creates an `AdminLog` entry.
- **Assured Data**: Ensures ownership transfer and logging happen together, maintaining auditability.
- **Auto Rollback**: If the log save fails (e.g., database issue), the ownership change is rolled back.
- **Real-World Use**: Critical for tracking admin actions in systems requiring audit trails, like election management.

---

### Why Transactions Are Critical in These Examples

1. **Multiple Entities**:

   - Each example involves at least two entities (e.g., `Election` and `ElectionOption`, `ElectionOption` and `Election`, `Election` and `AdminLog`).
   - Without transactions, a partial failure could create inconsistent data (e.g., an election without options or a vote count mismatch).

2. **Assured Data**:

   - Transactions enforce constraints (e.g., foreign keys, unique fields) before committing.
   - Example: In the voting scenario, the transaction ensures `ElectionOption.electionId` matches a valid `Election.id`.

3. **Auto Rollback**:
   - If any operation fails (e.g., validation error, database timeout), all changes are reverted.
   - Example: In the ownership transfer, a failure in logging prevents the `createdBy` update, maintaining consistency.

---

### Transaction Best Practices in NestJS

- **Use `DataSource.transaction`**: Preferred for TypeORM as it provides a clean API.
- **Keep Transactions Short**: Minimize operations to reduce lock duration and improve performance.
- **Handle Errors**: Catch specific errors (e.g., `NotFoundException`) and map to appropriate HTTP responses.
- **Isolation Levels**: Set explicitly if needed (e.g., `manager.transaction('SERIALIZABLE', ...)` for strict isolation).
- **Testing**: Test rollback scenarios by simulating failures (e.g., invalid data, database errors).
- **Logging**: Use exception filters to log transaction failures for debugging.

---

### Integration with Exception Handling

Combine transactions with NestJS exceptions for robust APIs:

```typescript
// http-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  Logger,
} from "@nestjs/common";

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);

  catch(exception: any, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();
    const status =
      exception instanceof HttpException ? exception.getStatus() : 500;

    this.logger.error(`Error: ${exception.message}`, exception.stack);

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      message: exception.message || "Internal server error",
    });
  }
}
```

Register in `main.ts`:

```typescript
app.useGlobalFilters(new AllExceptionsFilter());
```

This ensures transaction failures (e.g., `BadRequestException`, `NotFoundException`) are caught and formatted consistently.

---

### Summary

- **Transactions**: Group database operations to ensure atomicity, consistency, isolation, and durability (ACID).
- **Why Use Them**:
  - **Multiple Entities**: Coordinate changes across tables (e.g., `Election` and `ElectionOption`).
  - **Assured Data**: Enforce constraints before committing.
  - **Auto Rollback**: Revert changes on failure to prevent partial updates.
- **Real-World Examples**:
  - Creating an election with options (ensures all options are saved).
  - Voting (keeps vote counts consistent across entities).
  - Transferring admin rights (logs actions atomically).
- **NestJS Implementation**: Use `DataSource.transaction` with TypeORM, combined with `ValidationPipe` and exception filters for robust error handling.
