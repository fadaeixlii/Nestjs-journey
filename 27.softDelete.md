## âœ… What is Soft Delete?

**Soft delete** means **marking a record as deleted without actually removing it from the database**. Instead of using `DELETE`, the record is **flagged** (e.g., with a `deletedAt` timestamp or `isDeleted` flag), so you can:

- Keep the data for logs/audits
- Restore if needed
- Maintain referential integrity

---

## ğŸ§  Real-World Use Cases

| Use Case                         | Why Soft Delete?                                                |
| -------------------------------- | --------------------------------------------------------------- |
| **User Accounts**                | To temporarily deactivate users and possibly restore them later |
| **Posts, Comments, or Messages** | Show "deleted by user" in UI but still keep history             |
| **E-commerce Orders/Products**   | Keep data for reports, refunds, logs                            |
| **Admin Panel Data**             | Admins can undelete items, or view deleted logs                 |
| **Auditing and Compliance**      | Required by law in some industries to not erase data            |

---

## âš™ï¸ Soft Delete in TypeORM (Using `@DeleteDateColumn`)

### Step 1: Add the column

```ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @DeleteDateColumn()
  deletedAt?: Date;
}
```

This enables TypeORMâ€™s **built-in soft delete**.

---

### Step 2: Use Repository or QueryBuilder

#### ğŸ” Soft delete an entity:

```ts
await userRepository.softDelete(userId);
```

This sets the `deletedAt` column to the current timestamp â€” doesnâ€™t remove the row.

---

#### ğŸ—ƒï¸ Find all **non-deleted** users:

```ts
const users = await userRepository.find(); // by default, excludes soft-deleted
```

---

#### ğŸ” Include deleted:

```ts
const users = await userRepository.find({
  withDeleted: true,
});
```

---

#### ğŸ“¤ Restore soft-deleted item:

```ts
await userRepository.restore(userId);
```

---

## ğŸ”§ Using QueryBuilder (Advanced)

```ts
await dataSource
  .createQueryBuilder()
  .softDelete()
  .from(User)
  .where("id = :id", { id: 1 })
  .execute();
```

---

## ğŸ§± Comparison: Soft Delete vs Hard Delete

| Operation            | Soft Delete | Hard Delete |
| -------------------- | ----------- | ----------- |
| Removes from DB?     | âŒ No       | âœ… Yes      |
| Reversible?          | âœ… Yes      | âŒ No       |
| Breaks foreign keys? | âŒ No       | âœ… Possibly |
| Affects indexes?     | âŒ No       | âœ… Yes      |
| Auditable?           | âœ… Yes      | âŒ No       |

---

## âš ï¸ Common Pitfalls

| Pitfall                                         | Fix                                                   |
| ----------------------------------------------- | ----------------------------------------------------- |
| âŒ `find()` doesnâ€™t return soft-deleted items   | Use `{ withDeleted: true }`                           |
| âŒ Using `.delete()` instead of `.softDelete()` | Use `.softDelete()` when soft deletion is desired     |
| âŒ Confusion with cascade deletes               | Soft delete wonâ€™t cascade unless implemented manually |
| âŒ Soft deleted items showing in relations      | You must filter them manually with query or scopes    |

---

## âœ… Best Practices

- Use `@DeleteDateColumn` for timestamp-based soft delete (more flexible than `isDeleted: boolean`)
- Add global filters or custom repository to handle filtering out deleted records
- Always test restore logic
- Mark soft-deleted records clearly in admin panels
- Track soft-deleted events in logs for audit trails

---

## âœ¨ Bonus: Soft Delete with `BaseEntity`

You can create a reusable base entity:

```ts
export abstract class BaseSoftDeleteEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @DeleteDateColumn()
  deletedAt?: Date;
}
```

Then extend it:

```ts
@Entity()
export class Post extends BaseSoftDeleteEntity {
  @Column()
  title: string;
}
```
