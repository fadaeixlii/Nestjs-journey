## ✅ What is Soft Delete?

**Soft delete** means **marking a record as deleted without actually removing it from the database**. Instead of using `DELETE`, the record is **flagged** (e.g., with a `deletedAt` timestamp or `isDeleted` flag), so you can:

- Keep the data for logs/audits
- Restore if needed
- Maintain referential integrity

---

## 🧠 Real-World Use Cases

| Use Case                         | Why Soft Delete?                                                |
| -------------------------------- | --------------------------------------------------------------- |
| **User Accounts**                | To temporarily deactivate users and possibly restore them later |
| **Posts, Comments, or Messages** | Show "deleted by user" in UI but still keep history             |
| **E-commerce Orders/Products**   | Keep data for reports, refunds, logs                            |
| **Admin Panel Data**             | Admins can undelete items, or view deleted logs                 |
| **Auditing and Compliance**      | Required by law in some industries to not erase data            |

---

## ⚙️ Soft Delete in TypeORM (Using `@DeleteDateColumn`)

### Step 1: Add the column

```ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @DeleteDateColumn()
  deletedAt?: Date;
}
```

This enables TypeORM’s **built-in soft delete**.

---

### Step 2: Use Repository or QueryBuilder

#### 🔁 Soft delete an entity:

```ts
await userRepository.softDelete(userId);
```

This sets the `deletedAt` column to the current timestamp — doesn’t remove the row.

---

#### 🗃️ Find all **non-deleted** users:

```ts
const users = await userRepository.find(); // by default, excludes soft-deleted
```

---

#### 🔍 Include deleted:

```ts
const users = await userRepository.find({
  withDeleted: true,
});
```

---

#### 📤 Restore soft-deleted item:

```ts
await userRepository.restore(userId);
```

---

## 🔧 Using QueryBuilder (Advanced)

```ts
await dataSource
  .createQueryBuilder()
  .softDelete()
  .from(User)
  .where("id = :id", { id: 1 })
  .execute();
```

---

## 🧱 Comparison: Soft Delete vs Hard Delete

| Operation            | Soft Delete | Hard Delete |
| -------------------- | ----------- | ----------- |
| Removes from DB?     | ❌ No       | ✅ Yes      |
| Reversible?          | ✅ Yes      | ❌ No       |
| Breaks foreign keys? | ❌ No       | ✅ Possibly |
| Affects indexes?     | ❌ No       | ✅ Yes      |
| Auditable?           | ✅ Yes      | ❌ No       |

---

## ⚠️ Common Pitfalls

| Pitfall                                         | Fix                                                   |
| ----------------------------------------------- | ----------------------------------------------------- |
| ❌ `find()` doesn’t return soft-deleted items   | Use `{ withDeleted: true }`                           |
| ❌ Using `.delete()` instead of `.softDelete()` | Use `.softDelete()` when soft deletion is desired     |
| ❌ Confusion with cascade deletes               | Soft delete won’t cascade unless implemented manually |
| ❌ Soft deleted items showing in relations      | You must filter them manually with query or scopes    |

---

## ✅ Best Practices

- Use `@DeleteDateColumn` for timestamp-based soft delete (more flexible than `isDeleted: boolean`)
- Add global filters or custom repository to handle filtering out deleted records
- Always test restore logic
- Mark soft-deleted records clearly in admin panels
- Track soft-deleted events in logs for audit trails

---

## ✨ Bonus: Soft Delete with `BaseEntity`

You can create a reusable base entity:

```ts
export abstract class BaseSoftDeleteEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @DeleteDateColumn()
  deletedAt?: Date;
}
```

Then extend it:

```ts
@Entity()
export class Post extends BaseSoftDeleteEntity {
  @Column()
  title: string;
}
```
