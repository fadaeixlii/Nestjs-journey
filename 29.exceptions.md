### How Exceptions Work in NestJS

1. **Throwing Exceptions**: When an error condition is detected (e.g., invalid input, resource not found), you throw an exception using one of NestJS's built-in exception classes or a custom one.
2. **Exception Handling**: NestJS catches the exception and converts it into an HTTP response with an appropriate status code and error message.
3. **Default Behavior**: If no custom handling is defined, NestJS returns a JSON response with the status code, message, and error details.

### What is an Exception Filter?

An **Exception Filter** in NestJS is a mechanism to intercept and handle exceptions thrown during request processing. It allows you to customize the response, log errors, or perform additional logic before sending the response to the client. Filters are implemented using the `@Catch()` decorator and the `ExceptionFilter` interface.

#### Structure of an Exception Filter

```typescript
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
} from "@nestjs/common";
import { Response } from "express";

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const status = exception.getStatus();
    const message = exception.getResponse();

    response.status(status).json({
      statusCode: status,
      message,
      timestamp: new Date().toISOString(),
    });
  }
}
```

- **`@Catch()`**: Specifies which exceptions the filter handles (e.g., `HttpException` or a custom one).
- **`ArgumentsHost`**: Provides context about the request (HTTP, WebSocket, etc.).
- **Custom Logic**: You can modify the response, log errors, or add metadata (e.g., timestamps).

#### Applying an Exception Filter

Filters can be applied globally, at the controller level, or at the route level:

```typescript
// Global
app.useGlobalFilters(new HttpExceptionFilter());

// Controller
@UseFilters(HttpExceptionFilter)
@Controller('example')
export class ExampleController {}

// Route
@UseFilters(HttpExceptionFilter)
@Get('example')
getExample() {}
```

### Built-in Exceptions in NestJS

NestJS provides several built-in exception classes that extend the base `HttpException` class. Each has a specific HTTP status code and use case. Below is a list of common built-in exceptions with short explanations and real-world examples.

#### 1. **HttpException**

- **Description**: Base class for all HTTP exceptions. Allows custom status codes and messages.
- **Status Code**: Any (user-defined).
- **Real-World Example**: A generic error when a user tries to access an unsupported API endpoint.
  ```typescript
  throw new HttpException("This endpoint is not supported", 400);
  ```
  **Response**:
  ```json
  {
    "statusCode": 400,
    "message": "This endpoint is not supported"
  }
  ```

#### 2. **BadRequestException**

- **Description**: Indicates invalid request data (e.g., missing or incorrect fields).
- **Status Code**: 400
- **Real-World Example**: A user submits a registration form without an email.
  ```typescript
  throw new BadRequestException("Email is required");
  ```
  **Response**:
  ```json
  {
    "statusCode": 400,
    "message": "Email is required",
    "error": "Bad Request"
  }
  ```

#### 3. **UnauthorizedException**

- **Description**: Indicates the user is not authenticated or lacks valid credentials.
- **Status Code**: 401
- **Real-World Example**: A user tries to access a protected resource without a valid JWT token.
  ```typescript
  throw new UnauthorizedException("Invalid or missing token");
  ```
  **Response**:
  ```json
  {
    "statusCode": 401,
    "message": "Invalid or missing token",
    "error": "Unauthorized"
  }
  ```

#### 4. **ForbiddenException**

- **Description**: Indicates the user is authenticated but lacks permission for the resource.
- **Status Code**: 403
- **Real-World Example**: A regular user tries to access an admin-only dashboard.
  ```typescript
  throw new ForbiddenException("You do not have admin privileges");
  ```
  **Response**:
  ```json
  {
    "statusCode": 403,
    "message": "You do not have admin privileges",
    "error": "Forbidden"
  }
  ```

#### 5. **NotFoundException**

- **Description**: Indicates the requested resource does not exist.
- **Status Code**: 404
- **Real-World Example**: A user tries to fetch a product by an invalid ID.
  ```typescript
  throw new NotFoundException("Product with ID 123 not found");
  ```
  **Response**:
  ```json
  {
    "statusCode": 404,
    "message": "Product with ID 123 not found",
    "error": "Not Found"
  }
  ```

#### 6. **ConflictException**

- **Description**: Indicates a conflict with the current state of the resource (e.g., duplicate data).
- **Status Code**: 409
- **Real-World Example**: A user tries to register with an already-used email.
  ```typescript
  throw new ConflictException("Email already exists");
  ```
  **Response**:
  ```json
  {
    "statusCode": 409,
    "message": "Email already exists",
    "error": "Conflict"
  }
  ```

#### 7. **InternalServerErrorException**

- **Description**: Indicates a generic server error (used when no specific exception applies).
- **Status Code**: 500
- **Real-World Example**: A database connection fails unexpectedly.
  ```typescript
  throw new InternalServerErrorException("Failed to connect to database");
  ```
  **Response**:
  ```json
  {
    "statusCode": 500,
    "message": "Failed to connect to database",
    "error": "Internal Server Error"
  }
  ```

#### 8. **NotImplementedException**

- **Description**: Indicates a feature or endpoint is not yet implemented.
- **Status Code**: 501
- **Real-World Example**: A placeholder for a future API endpoint.
  ```typescript
  throw new NotImplementedException("This feature is under development");
  ```
  **Response**:
  ```json
  {
    "statusCode": 501,
    "message": "This feature is under development",
    "error": "Not Implemented"
  }
  ```

#### 9. **BadGatewayException**

- **Description**: Indicates the server received an invalid response from an upstream server.
- **Status Code**: 502
- **Real-World Example**: A service fails to get a response from a third-party payment gateway.
  ```typescript
  throw new BadGatewayException("Payment gateway is down");
  ```
  **Response**:
  ```json
  {
    "statusCode": 502,
    "message": "Payment gateway is down",
    "error": "Bad Gateway"
  }
  ```

#### 10. **ServiceUnavailableException**

- **Description**: Indicates the server is temporarily unable to handle the request.
- **Status Code**: 503
- **Real-World Example**: A service is down for scheduled maintenance.
  ```typescript
  throw new ServiceUnavailableException("Server under maintenance");
  ```
  **Response**:
  ```json
  {
    "statusCode": 503,
    "message": "Server under maintenance",
    "error": "Service Unavailable"
  }
  ```

#### 11. **GatewayTimeoutException**

- **Description**: Indicates the server did not receive a timely response from an upstream server.
- **Status Code**: 504
- **Real-World Example**: A third-party API takes too long to respond.
  ```typescript
  throw new GatewayTimeoutException("Third-party API timed out");
  ```
  **Response**:
  ```json
  {
    "statusCode": 504,
    "message": "Third-party API timed out",
    "error": "Gateway Timeout"
  }
  ```

### Custom Exceptions

You can create custom exceptions by extending `HttpException`:

```typescript
export class CustomException extends HttpException {
  constructor(message: string) {
    super(message, 400);
  }
}
```

**Usage**:

```typescript
throw new CustomException("Invalid user input");
```

### Real-World Example of Exception Filter in Action

Suppose you want to log all errors and add a custom error code:

```typescript
@Catch(HttpException)
export class CustomHttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const status = exception.getStatus();
    const message = exception.getResponse();

    // Log error to a service
    console.log(`Error occurred: ${message}`);

    response.status(status).json({
      statusCode: status,
      message,
      errorCode: `ERR_${status}_${Date.now()}`,
      timestamp: new Date().toISOString(),
    });
  }
}
```

**Response Example** (for a `NotFoundException`):

```json
{
  "statusCode": 404,
  "message": "Product with ID 123 not found",
  "errorCode": "ERR_404_1697041234567",
  "timestamp": "2025-08-08T10:21:00.000Z"
}
```

### Summary

- **Exceptions** in NestJS standardize error handling with built-in classes like `BadRequestException`, `NotFoundException`, etc.
- **Exception Filters** allow custom handling of exceptions, enabling tailored responses, logging, or additional logic.
- Each built-in exception maps to a specific HTTP status code and use case, making it easy to handle common scenarios like invalid input, unauthorized access, or server errors.
- Custom exceptions and filters provide flexibility for application-specific error handling.
