## üîÅ What is a Many-to-Many Relationship?

A **Many-to-Many** relationship exists when multiple records in one table relate to multiple records in another.

### üìå Real-world Examples:

- **Users and Roles** (A user can have many roles, a role can be assigned to many users)
- **Students and Courses** (A student can enroll in many courses, a course has many students)
- **Products and Tags** (A product can have many tags, and a tag can belong to many products)

---

## üîÑ Bidirectional vs Unidirectional

### üîÅ Bidirectional:

Both entities **know about each other** and you can navigate the relation from either side.

### üîÄ Unidirectional:

Only **one entity** holds the relation.

---

## üèóÔ∏è Creating a Many-to-Many (Bidirectional) Relation in TypeORM

### Example: Users & Roles

```ts
// user.entity.ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  username: string;

  @ManyToMany(() => Role, (role) => role.users, {
    cascade: true, // optional
  })
  @JoinTable() // <== Required only on one side!
  roles: Role[];
}
```

```ts
// role.entity.ts
@Entity()
export class Role {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @ManyToMany(() => User, (user) => user.roles)
  users: User[];
}
```

### This will generate a join table like:

```sql
user_roles
-----------
userId | roleId
```

---

## üîÄ Unidirectional Many-to-Many

Only one side is aware:

```ts
// Product entity knows about tags
@Entity()
export class Product {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @ManyToMany(() => Tag, { cascade: true })
  @JoinTable()
  tags: Tag[];
}

// Tag has no relation back
@Entity()
export class Tag {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  label: string;
}
```

---

## üß† What Does `@JoinTable()` Do?

- Creates a **join table** in the database.
- Required only on **one** side of the relation.
- You can configure the name & columns like this:

```ts
@JoinTable({
  name: 'user_roles',
  joinColumn: { name: 'user_id', referencedColumnName: 'id' },
  inverseJoinColumn: { name: 'role_id', referencedColumnName: 'id' },
})
```

---

## ‚úÖ Inserting Many-to-Many Relations

```ts
const role1 = new Role();
role1.name = "Admin";

const role2 = new Role();
role2.name = "Editor";

const user = new User();
user.username = "john";
user.roles = [role1, role2];

await userRepo.save(user);
```

- Ensure `cascade: true` or manually save `Role` entities first

---

## üõ†Ô∏è Updating Many-to-Many

### Replace All Roles:

```ts
const user = await userRepo.findOne({
  where: { id: 1 },
  relations: ["roles"],
});

const newRole = await roleRepo.findOneBy({ id: 3 });

user.roles = [newRole];

await userRepo.save(user); // Updates roles for user
```

---

### Add One Role:

```ts
user.roles.push(newRole);
await userRepo.save(user);
```

---

### Remove a Role:

```ts
user.roles = user.roles.filter((r) => r.id !== roleToRemove.id);
await userRepo.save(user);
```

---

## ‚ùå Deleting Related Entity

If you delete a role directly:

```ts
await roleRepo.delete(roleId);
```

The entry in the join table will be removed **only** if:

- You set up **`onDelete: 'CASCADE'`** on the relation manually in DB
- Or you manually clean join table entries

To remove relation without deleting Role entity:

```ts
user.roles = user.roles.filter((role) => role.id !== roleId);
await userRepo.save(user);
```

---

## üß© Real-World Example: Student & Course

```ts
@Entity()
export class Student {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @ManyToMany(() => Course, (course) => course.students, { cascade: true })
  @JoinTable()
  courses: Course[];
}

@Entity()
export class Course {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @ManyToMany(() => Student, (student) => student.courses)
  students: Student[];
}
```

```ts
const student = await studentRepo.findOne({
  where: { id: 1 },
  relations: ["courses"],
});

student.courses = student.courses.filter((c) => c.id !== 2); // Remove course
await studentRepo.save(student);
```

---

## üß† Best Practices & Tips

| Best Practice                                  | Description                                  |
| ---------------------------------------------- | -------------------------------------------- |
| ‚úÖ Use `@JoinTable()` only once                | Only one side should define `@JoinTable()`   |
| ‚ö†Ô∏è Avoid cascade on untrusted input            | Prevent security issues with nested inserts  |
| ‚úÖ Always use `relations: [...]` when updating | Required to work with loaded relations       |
| ‚ö†Ô∏è Don‚Äôt use plain objects as related entities | Use entity instances                         |
| ‚úÖ Use `.findOne(..., { relations: [...] })`   | Load related data before modifying it        |
| ‚úÖ Use DTOs for many-to-many creation          | Map input into proper entity format with IDs |
| ‚úÖ Use transaction for bulk add/remove         | Keep integrity in large nested updates       |
