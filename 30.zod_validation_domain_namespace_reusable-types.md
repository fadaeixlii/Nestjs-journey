### Understanding the Branded Type Structure

The branded type pattern you’ve shared uses Zod with TypeScript’s type branding to create strongly typed, domain-specific types (e.g., `Url`, `WholeNumber`, `ChamberOfCommerceNumber`). This approach enhances type safety by distinguishing between otherwise identical primitive types (e.g., a `string` that’s a `Url` vs. a plain `string`). Let’s break down the structure using your examples.

#### Branded Type Pattern

The pattern typically includes:

1. **Type Definition with Branding**:

   - Uses a generic `Brand` type to tag a base type (e.g., `string`, `number`) with a unique identifier.
   - Example:
     ```typescript
     export type Brand<K, T extends string> = K & z.BRAND<T>;
     export type Url = Brand<string, "Url">;
     ```
     Here, `Url` is a `string` tagged with `'Url'`, making it distinct from other strings at the type level.

2. **Namespace for Validation and Utilities**:

   - A `namespace` (e.g., `Url`, `WholeNumber`) encapsulates validation logic and utilities.
   - Key components:
     - `is`: A type guard to check if a value conforms to the branded type.
     - `zod`: A Zod schema for runtime validation.
     - `mk`: A safe constructor that returns the branded type or `undefined` if invalid.
     - `mkUnsafe`: A constructor that throws an error if the value is invalid.

   Example (`Url`):

   ```typescript
   export namespace Url {
     export const is = (str: string): str is Url =>
       z.string().url().safeParse(str).success;
     export const zod = z
       .string()
       .refine(is, { message: "Url" })
       .brand<"Url">();
   }
   ```

   Example (`WholeNumber`):

   ```typescript
   export type WholeNumber = Int & GraterEqThanZero;
   export namespace WholeNumber {
     export const is = (x: number): x is WholeNumber =>
       Int.is(x) && GraterEqThanZero.is(x);
     export const zod = z.number().refine(is, { message: "WholeNumber" });
     export const mk = (num: number) => (is(num) ? num : undefined);
     export const mkUnsafe = (num: number) => {
       const n = mk(num);
       if (n === undefined) throw new Error("Should whole number");
       return n;
     };
   }
   ```

3. **Composition**:

   - Types like `WholeNumber` combine other branded types (`Int`, `GraterEqThanZero`) for validation.
   - This promotes reusability and modularity.

4. **Zod Integration**:
   - The `zod` property uses Zod’s `refine` to enforce custom validation rules and `brand` to align with the TypeScript branded type.

#### Benefits of This Structure

- **Type Safety**: Prevents accidental misuse of primitive types (e.g., passing a plain `string` where a `Url` is expected).
- **Runtime Validation**: Zod schemas ensure data integrity at runtime.
- **Reusability**: Namespaces encapsulate logic, making it easy to reuse across the application.
- **Clear Error Messages**: Custom validation messages improve debugging and user feedback.

---

### Structuring Validation with `nestjs-zod`

The `nestjs-zod` package provides tools like `createZodDto`, `ZodValidationPipe`, and `ZodSerializerInterceptor` to streamline validation in NestJS. Below, I’ll show how to integrate your branded type pattern with `nestjs-zod` for both request and response validation, using a real-world example inspired by your code (e.g., a company review system).

#### Project Structure

Here’s a recommended structure for organizing validation logic:

```
src/
├── types/                       # Branded types and shared schemas
│   ├── brand.ts                 # Brand type definition
│   ├── url.ts                   # Url branded type
│   ├── whole-number.ts          # WholeNumber branded type
│   ├── greater-eq-than-zero.ts  # GraterEqThanZero branded type
│   ├── bounded-natural-number.ts # BoundedNaturalNumber branded type
│   ├── non-empty-string.ts      # NonEmptyString branded type
│   └── company-id.ts            # CompanyId branded type
├── modules/
│   ├── company/                 # Company module
│   │   ├── domain/              # Domain models and types
│   │   │   └── company.ts       # Company type and schemas
│   │   ├── dto/                 # DTOs for request/response
│   │   │   └── create-review.dto.ts
│   │   ├── entity/              # Database entities
│   │   │   └── review.entity.ts
│   │   ├── company.controller.ts
│   │   ├── company.service.ts
│   │   └── company.module.ts
├── shared/
│   └── errors/                  # Custom errors
│       └── forbidden.error.ts
├── main.ts                      # Application bootstrap
└── app.module.ts                # Root module
```

---

### Implementing Validation with `nestjs-zod`

Let’s build a company review system where users submit reviews with a rating, comment, and company ID, using your branded types and `nestjs-zod`.

#### Step 1: Define Branded Types

**`src/types/brand.ts`**:

```typescript
import { z } from "zod";

export type Brand<K, T extends string> = K & z.BRAND<T>;
```

**`src/types/non-empty-string.ts`**:

```typescript
import { z } from "zod";
import { Brand } from "./brand";

export type NonEmptyString = Brand<string, "NonEmptyString">;

export namespace NonEmptyString {
  export const is = (str: string): str is NonEmptyString =>
    str.trim().length > 0;
  export const zod = z
    .string()
    .refine(is, { message: "Must be a non-empty string" })
    .brand<"NonEmptyString">();
  export const mk = (str: string) => (is(str) ? str : undefined);
  export const mkUnsafe = (str: string) => {
    const s = mk(str);
    if (s === undefined) throw new Error("Must be a non-empty string");
    return s;
  };
}
```

**`src/types/bounded-natural-number.ts`**:

```typescript
import { z } from "zod";
import { WholeNumber } from "./whole-number";

export type BoundedNaturalNumber<
  Min extends number = number,
  Max extends number = number
> = WholeNumber & z.BRAND<`BoundedNaturalNumber_${Min}_${Max}`>;

export namespace BoundedNaturalNumber {
  export const is = <Min extends number, Max extends number>(
    num: number,
    min: Min,
    max: Max
  ): num is BoundedNaturalNumber<Min, Max> =>
    WholeNumber.is(num) && num >= min && num <= max;

  export const zod = <Min extends number, Max extends number>(
    min: Min,
    max: Max
  ) =>
    z
      .number()
      .refine((num) => is(num, min, max), {
        message: `Must be a whole number between ${min} and ${max}`,
      })
      .brand<`BoundedNaturalNumber_${Min}_${Max}`>();

  export const mk = <Min extends number, Max extends number>(
    num: number,
    min: Min,
    max: Max
  ) => (is(num, min, max) ? num : undefined);

  export const mkUnsafe = <Min extends number, Max extends number>(
    num: number,
    min: Min,
    max: Max
  ) => {
    const n = mk(num, min, max);
    if (n === undefined)
      throw new Error(`Must be a whole number between ${min} and ${max}`);
    return n;
  };
}
```

**`src/types/company-id.ts`**:

```typescript
import { z } from "zod";
import { Brand } from "./brand";

export type CompanyId = Brand<string, "CompanyId">;

export namespace CompanyId {
  export const is = (str: string): str is CompanyId =>
    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/.test(str);
  export const zod = z
    .string()
    .refine(is, { message: "Invalid UUID for CompanyId" })
    .brand<"CompanyId">();
  export const mk = (str: string) => (is(str) ? str : undefined);
  export const mkUnsafe = (str: string) => {
    const s = mk(str);
    if (s === undefined) throw new Error("Invalid UUID for CompanyId");
    return s;
  };
}
```

**Note**: I’ve simplified `WholeNumber` and `GraterEqThanZero` dependencies for brevity, but they follow the same pattern as shown in your examples.

#### Step 2: Define Domain Models

**`src/modules/company/domain/company.ts`**:

```typescript
import { z } from "zod";
import { CompanyId } from "src/types/company-id";
import { NonEmptyString, BoundedNaturalNumber } from "src/types";

export type Company = {
  id: CompanyId;
  name: NonEmptyString;
  rating: number;
};

export namespace Company {
  export const zod = z.object({
    id: CompanyId.zod,
    name: NonEmptyString.zod,
    rating: BoundedNaturalNumber.zod(1, 5),
  });

  export type Dto = z.infer<typeof zod>;
}
```

#### Step 3: Define DTOs with `createZodDto`

**`src/modules/company/dto/create-review.dto.ts`**:

```typescript
import { createZodDto } from "nestjs-zod";
import { z } from "zod";
import { CompanyId, NonEmptyString, BoundedNaturalNumber } from "src/types";

export type CreateReviewDto = CreateReviewDto.Dto;

export namespace CreateReviewDto {
  export const schema = z.object({
    companyId: CompanyId.zod,
    rating: BoundedNaturalNumber.zod(1, 5),
    comment: NonEmptyString.zod,
  });

  export class Input extends createZodDto(schema) {}
  export type Dto = z.infer<typeof schema>;
}
```

#### Step 4: Define Entities

**`src/modules/company/entity/review.entity.ts`**:

```typescript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";
import { z } from "zod";
import { CompanyId, NonEmptyString, BoundedNaturalNumber } from "src/types";

@Entity("reviews")
export class ReviewEntity {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column()
  companyId: string;

  @Column()
  rating: number;

  @Column()
  comment: string;

  static schema = z.object({
    id: z.string().uuid(),
    companyId: CompanyId.zod,
    rating: BoundedNaturalNumber.zod(1, 5),
    comment: NonEmptyString.zod,
  });

  toDomain(): z.infer<typeof ReviewEntity.schema> {
    return ReviewEntity.schema.parse(this);
  }
}
```

#### Step 5: Set Up Global Validation

**`src/app.module.ts`**:

```typescript
import { Module } from "@nestjs/common";
import { APP_INTERCEPTOR, APP_PIPE } from "@nestjs/core";
import { ZodValidationPipe, ZodSerializerInterceptor } from "nestjs-zod";
import { CompanyModule } from "./modules/company/company.module";

@Module({
  imports: [CompanyModule],
  providers: [
    { provide: APP_PIPE, useClass: ZodValidationPipe },
    { provide: APP_INTERCEPTOR, useClass: ZodSerializerInterceptor },
  ],
})
export class AppModule {}
```

**Note**: Setting `ZodValidationPipe` globally ensures all incoming requests with DTOs are validated. `ZodSerializerInterceptor` ensures responses conform to specified schemas.

#### Step 6: Implement Controller and Service

**`src/modules/company/company.service.ts`**:

```typescript
import { Injectable } from "@nestjs/common";
import { CreateReviewDto } from "./dto/create-review.dto";
import { ReviewEntity } from "./entity/review.entity";
import { Company } from "./domain/company";

@Injectable()
export class CompanyService {
  private reviews: ReviewEntity[] = []; // Mock storage
  private companies: Company[] = []; // Mock storage

  createReview(dto: CreateReviewDto.Dto): ReviewEntity {
    const review = new ReviewEntity();
    review.id = crypto.randomUUID();
    review.companyId = dto.companyId;
    review.rating = dto.rating;
    review.comment = dto.comment;
    this.reviews.push(review);
    return review;
  }

  getCompany(id: CompanyId): Company {
    const reviews = this.reviews.filter((r) => r.companyId === id);
    const rating = reviews.length
      ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length
      : 0;
    return {
      id,
      name: "Example Company", // Mock data
      rating: Math.round(rating * 10) / 10,
    };
  }
}
```

**`src/modules/company/company.controller.ts`**:

```typescript
import { Controller, Post, Body, Get, Param } from "@nestjs/common";
import { CompanyService } from "./company.service";
import { CreateReviewDto } from "./dto/create-review.dto";
import { CompanyId } from "src/types/company-id";
import { Company } from "./domain/company";
import { ZodSerializerDto } from "nestjs-zod";

@Controller("companies")
export class CompanyController {
  constructor(private readonly companyService: CompanyService) {}

  @Post(":companyId/reviews")
  createReview(
    @Param("companyId") companyId: CompanyId,
    @Body() dto: CreateReviewDto.Input
  ) {
    return this.companyService.createReview({ ...dto, companyId });
  }

  @Get(":companyId")
  @ZodSerializerDto(Company.zod)
  getCompany(@Param("companyId") companyId: CompanyId): Company {
    return this.companyService.getCompany(companyId);
  }
}
```

**`src/modules/company/company.module.ts`**:

```typescript
import { Module } from "@nestjs/common";
import { CompanyService } from "./company.service";
import { CompanyController } from "./company.controller";

@Module({
  controllers: [CompanyController],
  providers: [CompanyService],
})
export class CompanyModule {}
```

#### Step 7: Custom Error Handling

**`src/shared/errors/forbidden.error.ts`**:

```typescript
export class ForbiddenError extends Error {
  static mk(message: string): ForbiddenError {
    return new ForbiddenError(message);
  }
}
```

**`src/main.ts`**:

```typescript
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import { patchNestJsSwagger } from "nestjs-zod";
import { SwaggerModule, DocumentBuilder } from "@nestjs/swagger";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Apply Swagger patch for nestjs-zod
  patchNestJsSwagger();

  const config = new DocumentBuilder()
    .setTitle("Company API")
    .setVersion("1.0")
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup("api", app, document);

  await app.listen(3000);
}
bootstrap();
```

---

### Explanation of Key Components

1. **Branded Types**:

   - Types like `CompanyId`, `NonEmptyString`, and `BoundedNaturalNumber` use the `Brand` pattern to ensure type safety.
   - The `namespace` pattern (e.g., `NonEmptyString.is`, `NonEmptyString.zod`) encapsulates validation logic, making it reusable and testable.
   - Example: `BoundedNaturalNumber.zod(1, 5)` creates a schema for numbers between 1 and 5, branded with a unique type.

2. **Request Validation**:

   - `createZodDto` is used to create DTO classes (e.g., `CreateReviewDto.Input`) that integrate with `ZodValidationPipe`.
   - The global `ZodValidationPipe` validates all incoming requests with DTOs, throwing `ZodValidationException` on errors.
   - Example: The `CreateReviewDto` ensures `companyId`, `rating`, and `comment` are valid before reaching the service.

3. **Response Validation**:

   - The `@ZodSerializerDto(Company.zod)` decorator ensures the `getCompany` response conforms to the `Company` schema, preventing accidental data leaks (e.g., internal fields).
   - The global `ZodSerializerInterceptor` applies this validation to all endpoints with `@ZodSerializerDto`.

4. **Error Handling**:

   - `ZodValidationException` provides structured error responses (e.g., `statusCode: 400, message: "Validation failed", errors: [...]`).
   - Custom errors like `ForbiddenError` are used for domain-specific cases.

5. **Swagger Integration**:
   - The `patchNestJsSwagger` function enables Zod schemas to generate accurate OpenAPI definitions.
   - Example: The `Company.zod` schema is automatically converted to Swagger schema for the `getCompany` endpoint.

---

### Testing the API

**Create a Review**:

```bash
curl -X POST http://localhost:3000/companies/123e4567-e89b-12d3-a456-426614174000/reviews \
  -H "Content-Type: application/json" \
  -d '{
    "companyId": "123e4567-e89b-12d3-a456-426614174000",
    "rating": 4,
    "comment": "Great service!"
  }'
```

**Response** (Success):

```json
{
  "id": "uuid",
  "companyId": "123e4567-e89b-12d3-a456-426614174000",
  "rating": 4,
  "comment": "Great service!"
}
```

**Response** (Invalid Data):

```json
{
  "statusCode": 400,
  "message": "Validation failed",
  "errors": [
    {
      "code": "custom",
      "message": "Must be a whole number between 1 and 5",
      "path": ["rating"]
    }
  ]
}
```

**Get a Company**:

```bash
curl http://localhost:3000/companies/123e4567-e89b-12d3-a456-426614174000
```

**Response**:

```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "name": "Example Company",
  "rating": 4
}
```

---

### Best Practices

1. **Centralize Branded Types**:

   - Store branded types in `src/types/` for reusability across modules.
   - Use namespaces to encapsulate validation logic.

2. **Use `createZodDto`**:

   - Create DTOs with `createZodDto` for request validation, ensuring type safety and runtime validation.

3. **Global Validation**:

   - Apply `ZodValidationPipe` and `ZodSerializerInterceptor` globally to minimize boilerplate.

4. **Response Validation**:

   - Use `@ZodSerializerDto` to enforce response shapes, especially for public APIs to prevent data leaks.

5. **Error Handling**:

   - Customize `ZodValidationException` for user-friendly error messages.
   - Use domain-specific errors (e.g., `ForbiddenError`) for business logic.

6. **Swagger Integration**:

   - Use `patchNestJsSwagger` and `.describe()` on schemas for better API documentation.

7. **Testing**:

   - Write unit tests for branded types and schemas:

     ```typescript
     import { describe, it, expect } from "vitest";
     import { BoundedNaturalNumber } from "src/types/bounded-natural-number";

     describe("BoundedNaturalNumber", () => {
       it("should validate a number in range", () => {
         const result = BoundedNaturalNumber.zod(1, 5).safeParse(4);
         expect(result.success).toBe(true);
       });

       it("should reject a number out of range", () => {
         const result = BoundedNaturalNumber.zod(1, 5).safeParse(6);
         expect(result.success).toBe(false);
         expect(result.error.errors[0].message).toBe(
           "Must be a whole number between 1 and 5"
         );
       });
     });
     ```

8. **Avoid Deprecated Features**:
   - Avoid `@nest-zod/z` (e.g., `z.dateString()`, `z.password()`) as it’s deprecated. Use native Zod with custom `refine` for similar functionality.

---

### Integrating with Your Examples

Your examples (e.g., `Company`, `CreateReview`, `ReviewEntity`) use branded types extensively. Here’s how they fit:

- **CompanyId**: A UUID-branded string, validated with a regex and Zod schema.
- **BoundedNaturalNumber**: Used for ratings (1–5), combining `WholeNumber` and range checks.
- **NonEmptyString**: Ensures comments and names are non-empty.
- **CreateReviewDto**: Combines branded types into a DTO, validated with `createZodDto`.
- **ReviewEntity**: Uses a Zod schema to validate database entities and transform them to domain models.

The `mk` and `mkUnsafe` functions are particularly useful for constructing domain objects safely:

```typescript
const rating = BoundedNaturalNumber.mkUnsafe(4, 1, 5); // Throws if invalid
const comment = NonEmptyString.mkUnsafe("Great service!"); // Throws if empty
```

---

### Conclusion

By combining `nestjs-zod` with your branded type pattern, you achieve a robust, type-safe, and maintainable validation system. The structure centralizes type definitions, leverages `ZodValidationPipe` for request validation, and uses `ZodSerializerInterceptor` for response validation. The branded types (`Url`, `WholeNumber`, etc.) ensure domain-specific constraints are enforced at both compile-time and runtime, while `nestjs-zod` integrates seamlessly with NestJS’s ecosystem.
