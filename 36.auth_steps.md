---

### 1. Abstract Class and Interface for Authentication (OOP Foundation)
**Purpose**: Establish a reusable, type-safe structure for authentication services using interfaces and abstract classes.

**Steps**:
1. Define an `AuthService` interface with methods: `signUp`, `signIn`, `refreshToken`, `logout`, `validateUser`.
2. Create an abstract class `AbstractAuthService` implementing the interface with abstract methods and shared properties (e.g., `dataSource` for TypeORM).
3. Use dependency injection to inject repositories (e.g., `AdminUser`) and services (e.g., `JwtService`).
4. Define typed responses (e.g., `{ accessToken: string, refreshToken: string }`) using branded types like `Id` from `IdMaker`.
5. Implement error handling with custom exceptions (e.g., `UnauthorizedException`).
6. Ensure extensibility for multiple auth strategies (e.g., local, OAuth).
7. Use `nestjs-zod` for DTO validation in concrete implementations.

---

### 2. Local Authentication (Username/Password)

**Purpose**: Authenticate users with username/email and password, using hashing for secure storage.

**Steps**:

1. Install `bcrypt` for password hashing.
2. Add `username`, `email`, and `password` fields to the `AdminUser` entity.
3. Create `SignUpDto` and `SignInDto` with `nestjs-zod` for input validation.
4. Implement `signUp` to hash passwords and save users using a transaction.
5. Implement `signIn` to verify credentials with `bcrypt.compare`.
6. Generate a JWT on successful login (see JWT section).
7. Throw `BadRequestException` for invalid inputs and `UnauthorizedException` for wrong credentials.
8. Use `ValidationPipe` globally to enforce DTO constraints.

---

### 3. JSON Web Tokens (JWT) Authentication

**Purpose**: Use JWTs for stateless, secure API authentication.

**Steps**:

1. Install `@nestjs/jwt` and `@nestjs/passport`.
2. Configure `JwtModule` with a secret and expiration (e.g., `15m`).
3. Define a `JwtPayload` interface (e.g., `{ userId: Id, role: string }`).
4. Implement `signIn` in `AuthService` to generate JWTs with `JwtService.sign`.
5. Create a `JwtAuthGuard` using `passport-jwt` to protect endpoints.
6. Validate JWT payloads by fetching users from the `AdminUser` repository.
7. Use environment variables for the JWT secret via `@nestjs/config`.
8. Handle token expiration with `UnauthorizedException`.

---

### 4. Refresh Tokens for Session Management

**Purpose**: Extend user sessions securely with refresh tokens, reducing frequent logins.

**Steps**:

1. Add a `refreshToken` field to the `AdminUser` entity for hashed tokens.
2. Generate refresh tokens in `signIn` (e.g., using `crypto.randomUUID` or `JwtService`).
3. Hash refresh tokens with `bcrypt` before storing.
4. Implement a `refreshToken` method to validate tokens and issue new JWTs.
5. Create a `RefreshTokenDto` with `nestjs-zod` for validation.
6. Use a transaction to update refresh tokens atomically.
7. Implement `logout` to invalidate refresh tokens.
8. Create a `RefreshTokenGuard` for refresh endpoints.

---

### 5. Session-Based Authentication

**Purpose**: Provide stateful authentication using server-side sessions, useful for admin dashboards.

**Steps**:

1. Install `express-session` and `@nestjs/session`.
2. Configure `SessionModule` with a secret and store (e.g., Redis for production).
3. Create a `SessionService` to manage session creation/destruction.
4. Store user ID and role in the session during `signIn`.
5. Implement a `SessionAuthGuard` to validate sessions.
6. Add `logout` to destroy sessions.
7. Configure secure cookies (`httpOnly`, `secure`) for production.
8. Use environment variables for session secrets.

---

### 6. OAuth 2.0 Authentication (e.g., Google, GitHub)

**Purpose**: Allow third-party authentication for voters or admins in the election system.

**Steps**:

1. Install `@nestjs/passport` and a provider strategy (e.g., `passport-google-oauth20`).
2. Configure `PassportModule` with client ID, secret, and callback URL.
3. Create an OAuth endpoint (e.g., `GET /auth/google`) to start the flow.
4. Implement a callback endpoint to handle provider responses.
5. Create or find an `AdminUser` based on OAuth profile data.
6. Generate JWT or session for authenticated users.
7. Use a transaction for user creation.
8. Throw `UnauthorizedException` for OAuth failures.

---

### 7. Two-Factor Authentication (2FA)

**Purpose**: Add an extra security layer for sensitive actions (e.g., admin election management).

**Steps**:

1. Install `speakeasy` for TOTP-based 2FA.
2. Add a `twoFactorSecret` field to the `AdminUser` entity.
3. Implement `enable2FA` to generate a secret and QR code.
4. Create `verify2FA` to validate TOTP codes during login.
5. Update `signIn` to require 2FA for enabled users.
6. Use a transaction for 2FA updates.
7. Throw `BadRequestException` for invalid 2FA codes.
8. Provide a recovery mechanism (e.g., backup codes).

---

### 8. Role-Based Access Control (RBAC)

**Purpose**: Restrict access to endpoints based on user roles (e.g., admin, voter).

**Steps**:

1. Add a `role` field to the `AdminUser` entity (e.g., `admin`, `voter`).
2. Include `role` in the JWT payload or session.
3. Create a `RolesGuard` to check user roles against endpoint requirements.
4. Use a `@Roles` decorator to annotate endpoints (e.g., `@Roles('admin')`).
5. Validate roles in `JwtAuthGuard` or `SessionAuthGuard`.
6. Throw `ForbiddenException` for unauthorized role access.
7. Use `nestjs-zod` to validate role inputs in DTOs.

---

### 9. Rate Limiting for Security

**Purpose**: Prevent brute-force attacks on authentication endpoints.

**Steps**:

1. Install `@nestjs/throttler`.
2. Configure `ThrottlerModule` with limits (e.g., 10 requests/minute).
3. Apply `@Throttle()` to endpoints like `POST /auth/signin`.
4. Customize error responses with a global exception filter.
5. Log rate limit violations for monitoring.
6. Adjust limits for production (e.g., stricter for login).
7. Exempt certain IPs (e.g., trusted admins) if needed.

---

### 10. Password Reset and Recovery

**Purpose**: Allow users to reset forgotten passwords securely.

**Steps**:

1. Add a `resetToken` field to the `AdminUser` entity.
2. Implement a `requestPasswordReset` method to generate a token and send an email.
3. Use a mailer service (e.g., `@nestjs-modules/mailer`) for emails.
4. Create a `resetPassword` endpoint to validate tokens and update passwords.
5. Hash new passwords with `bcrypt`.
6. Use a transaction for token and password updates.
7. Expire reset tokens after a short period (e.g., 1 hour).
8. Throw `BadRequestException` for invalid tokens.

---

### 11. Account Lockout for Brute-Force Protection

**Purpose**: Lock accounts after repeated failed login attempts.

**Steps**:

1. Add `failedLoginAttempts` and `lockoutUntil` fields to the `AdminUser` entity.
2. Increment `failedLoginAttempts` in `signIn` on failure.
3. Lock the account (set `lockoutUntil`) after a threshold (e.g., 5 attempts).
4. Check `lockoutUntil` before processing login attempts.
5. Reset `failedLoginAttempts` on successful login.
6. Use a transaction for atomic updates.
7. Throw `ForbiddenException` for locked accounts.
8. Implement an unlock mechanism (e.g., via email or admin action).

---

### 12. API Key Authentication (Optional, for Integrations)

**Purpose**: Allow third-party integrations with the election system using API keys.

**Steps**:

1. Create an `ApiKey` entity with fields: `key`, `userId`, `scopes`.
2. Generate unique API keys (e.g., using `crypto.randomUUID`).
3. Hash API keys with `bcrypt` before storing.
4. Implement an `ApiKeyAuthGuard` to validate keys in request headers.
5. Check scopes to restrict access (e.g., `read:elections`).
6. Use a transaction for key creation/revocation.
7. Throw `UnauthorizedException` for invalid keys.
8. Provide an endpoint to manage (create/revoke) keys.

---

### 13. Audit Logging for Authentication Events

**Purpose**: Track authentication actions for security and compliance.

**Steps**:

1. Create an `AuthLog` entity with fields: `userId`, `action`, `timestamp`, `ip`.
2. Log events (e.g., login, logout, token refresh) in `AuthService` methods.
3. Use a transaction to ensure logs are saved atomically with auth actions.
4. Implement a `findLogs` endpoint with pagination (using `Paginate` from your previous questions).
5. Restrict access to logs with `RolesGuard` (e.g., admin-only).
6. Use `nestjs-zod` for log query DTOs.
7. Throw `ForbiddenException` for unauthorized access.

---

### 14. Multi-Tenancy Authentication (Optional, for Multi-Organization Elections)

**Purpose**: Support authentication for multiple organizations (e.g., different election boards).

**Steps**:

1. Add a `tenantId` field to the `AdminUser` entity.
2. Include `tenantId` in JWT payload or session.
3. Create a `TenantGuard` to validate tenant access for endpoints.
4. Filter data (e.g., `Election`) by `tenantId` in queries.
5. Use a transaction for tenant-specific operations.
6. Throw `ForbiddenException` for cross-tenant access attempts.
7. Implement tenant-aware DTOs with `nestjs-zod`.

---

### 15. Best Practices for Authentication

**Purpose**: Ensure a secure, maintainable, and scalable authentication system.

**Steps**:

1. Use environment variables for secrets (JWT, session, OAuth) via `@nestjs/config`.
2. Enforce strong password policies (e.g., min length 8, mixed characters).
3. Store only hashed passwords and tokens with `bcrypt`.
4. Set short JWT expiration (e.g., 15m) and longer refresh token expiration (e.g., 7d).
5. Use HTTPS in production for data encryption.
6. Implement a global exception filter for consistent error responses.
7. Log all authentication events for auditing.
8. Use `ValidationPipe` with `nestjs-zod` for DTO validation.
9. Test edge cases (e.g., expired tokens, locked accounts) with unit tests.
10. Secure endpoints with appropriate guards (e.g., `JwtAuthGuard`, `RolesGuard`).

---

### Summary

**Authentication Methods**:

- **Local Authentication**: Username/password with hashed passwords, suitable for admin login.
- **JWT**: Stateless, scalable authentication for API access (e.g., voter or admin endpoints).
- **Refresh Tokens**: Extends sessions securely, ideal for user convenience.
- **Session-Based**: Stateful authentication for admin dashboards, using server-side sessions.
- **OAuth 2.0**: Third-party auth (e.g., Google) for voters or admins.
- **API Key**: For third-party integrations, with scoped access.
- **Multi-Tenancy**: Supports organization-specific auth in multi-board election systems.

**Security Features**:

- **Hashing/Salting**: Protects passwords with `bcrypt`.
- **2FA**: Adds security for sensitive actions.
- **Rate Limiting**: Prevents brute-force attacks.
- **Account Lockout**: Locks accounts after failed attempts.
- **Password Reset**: Securely recovers accounts.
- **Audit Logging**: Tracks auth events for compliance.
- **RBAC**: Restricts access by roles (e.g., admin vs. voter).

**Integration with Election System**:

- Use `AdminUser` for authentication (with `Id` from `IdMaker`).
- Apply pagination (from `Paginate`) to endpoints like `GET /auth/logs`.
- Use transactions for atomic operations (e.g., user creation, token updates).
- Leverage branded types (`NaturalNumber`, `WholeNumber`) for token expiration and counts.
