### Common Pagination Module

The module provides a reusable `PaginationService` to paginate any entity, supporting filters via a generic filter DTO. It calculates `skip`, `limit`, and metadata.

```typescript
import { Module, Injectable } from "@nestjs/common";
import { DataSource, SelectQueryBuilder } from "typeorm";
import { NaturalNumber, WholeNumber } from "./types";
import { IsOptional, IsString, IsEnum } from "class-validator";
import { Type } from "class-transformer";

// Pagination DTO
export class PaginationDto {
  @IsOptional()
  @Type(() => Number)
  page: WholeNumber = WholeNumber.mkUnsafe(1);

  @IsOptional()
  @Type(() => Number)
  limit: NaturalNumber = NaturalNumber.mkUnsafe(10);
}

// Filter DTO (example for Election)
export class ElectionFilterDto {
  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsEnum(["draft", "active", "closed"])
  status?: "draft" | "active" | "closed";
}

// Generic pagination response
export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    itemsPerPage: NaturalNumber;
    currentPage: WholeNumber;
    lastPage: WholeNumber;
    firstPage: WholeNumber;
    next: boolean;
    previous: boolean;
    totalItems: NaturalNumber;
  };
}

// Pagination service
@Injectable()
export class PaginationService {
  constructor(private dataSource: DataSource) {}

  async paginate<T>(
    queryBuilder: SelectQueryBuilder<T>,
    pagination: PaginationDto,
    filters?: Record<string, any>
  ): Promise<PaginatedResponse<T>> {
    const page = Math.max(WholeNumber.mkUnsafe(pagination.page), 1);
    const limit = Math.max(NaturalNumber.mkUnsafe(pagination.limit), 1);
    const skip = (page - 1) * limit;

    // Apply filters
    if (filters) {
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined) {
          queryBuilder.andWhere(`${queryBuilder.alias}.${key} = :${key}`, {
            [key]: value,
          });
        }
      });
    }

    // Get total count
    const totalItems = await queryBuilder.getCount();

    // Apply pagination
    queryBuilder.skip(skip).take(limit);

    // Execute query
    const data = await queryBuilder.getMany();

    // Calculate metadata
    const lastPage = Math.max(
      WholeNumber.mkUnsafe(Math.ceil(totalItems / limit)),
      1
    );
    const firstPage = WholeNumber.mkUnsafe(1);
    const next = page < lastPage;
    const previous = page > 1;

    return {
      data,
      meta: {
        itemsPerPage: limit,
        currentPage: page,
        lastPage,
        firstPage,
        next,
        previous,
        totalItems: NaturalNumber.mkUnsafe(totalItems),
      },
    };
  }
}

// Module
@Module({
  providers: [PaginationService],
  exports: [PaginationService],
})
export class PaginationModule {}
```

**Explanation**:

- **PaginationDto**: Defines `page` (WholeNumber, ≥1) and `limit` (NaturalNumber, ≥0) with default values.
- **ElectionFilterDto**: Example filter for `Election` entity (extendable for other entities).
- **PaginatedResponse**: Generic interface for `{ data, meta }` response structure.
- **PaginationService**:

  - Takes a `SelectQueryBuilder` for flexibility with any entity.
  - Applies filters dynamically using `andWhere`.
  - Calculates `skip` (`(page-1)*limit`) and `limit` for pagination.
  - Computes metadata (`lastPage`, `next`, `previous`, etc.).

- **Module**: Exports `PaginationService` for use across the app.

---

### Entity-Specific Implementation (Election Example)

#### Entity

```typescript
// election.entity.ts
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity("elections")
export class Election {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @Column()
  status: string;
}
```

#### Service

```typescript
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import {
  PaginationService,
  PaginationDto,
  ElectionFilterDto,
} from "./pagination.module";
import { Election } from "./election.entity";

@Injectable()
export class ElectionsService {
  constructor(
    @InjectRepository(Election)
    private electionRepository: Repository<Election>,
    private paginationService: PaginationService
  ) {}

  async findAll(pagination: PaginationDto, filters: ElectionFilterDto) {
    const queryBuilder = this.electionRepository.createQueryBuilder("election");
    return this.paginationService.paginate(queryBuilder, pagination, filters);
  }
}
```

#### Controller

```typescript
import { Controller, Get, Query } from "@nestjs/common";
import { ElectionsService } from "./elections.service";
import { PaginationDto, ElectionFilterDto } from "./pagination.module";

@Controller("elections")
export class ElectionsController {
  constructor(private electionsService: ElectionsService) {}

  @Get()
  async findAll(
    @Query() pagination: PaginationDto,
    @Query() filters: ElectionFilterDto
  ) {
    return this.electionsService.findAll(pagination, filters);
  }
}
```

---

### Example: Paginating Admin Users

#### Entity

```typescript
// admin-user.entity.ts
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity("admin_users")
export class AdminUser {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  username: string;
}
```

#### Filter DTO

```typescript
import { IsOptional, IsString } from "class-validator";

export class AdminFilterDto {
  @IsOptional()
  @IsString()
  username?: string;
}
```

#### Service

```typescript
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { PaginationService, PaginationDto } from "./pagination.module";
import { AdminUser } from "./admin-user.entity";
import { AdminFilterDto } from "./admin-filter.dto";

@Injectable()
export class AdminUsersService {
  constructor(
    @InjectRepository(AdminUser)
    private adminRepository: Repository<AdminUser>,
    private paginationService: PaginationService
  ) {}

  async findAll(pagination: PaginationDto, filters: AdminFilterDto) {
    const queryBuilder = this.adminRepository.createQueryBuilder("admin");
    return this.paginationService.paginate(queryBuilder, pagination, filters);
  }
}
```

#### Controller

```typescript
import { Controller, Get, Query } from "@nestjs/common";
import { AdminUsersService } from "./admin-users.service";
import { PaginationDto } from "./pagination.module";
import { AdminFilterDto } from "./admin-filter.dto";

@Controller("admin-users")
export class AdminUsersController {
  constructor(private adminUsersService: AdminUsersService) {}

  @Get()
  async findAll(
    @Query() pagination: PaginationDto,
    @Query() filters: AdminFilterDto
  ) {
    return this.adminUsersService.findAll(pagination, filters);
  }
}
```

---

### App Module

```typescript
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { PaginationModule } from "./pagination.module";
import { ElectionsModule } from "./elections.module";
import { AdminUsersModule } from "./admin-users.module";
import { Election } from "./election.entity";
import { AdminUser } from "./admin-user.entity";

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: "sqlite",
      database: ":memory:",
      entities: [Election, AdminUser],
      synchronize: true,
    }),
    PaginationModule,
    ElectionsModule,
    AdminUsersModule,
  ],
})
export class AppModule {}
```

---

### Key Features

1. **Reusable Pagination**:

   - Works with any TypeORM entity via `SelectQueryBuilder`.
   - Supports custom filters via a generic `filters` object.

2. **Branded Types**:

   - `NaturalNumber` for `limit`, `totalItems`, `itemsPerPage`.
   - `WholeNumber` for `page`, `firstPage`, `lastPage` to ensure positive integers.

3. **Skip and Limit**:

   - `skip = (page-1)*limit`.
   - `limit` controls items per page, with defaults and validation.

4. **Meta Data**:

   - Includes `itemsPerPage`, `currentPage`, `lastPage`, `firstPage`, `next`, `previous`, `totalItems`.

5. **Filters**:

   - Supports dynamic filtering.

6. **Error Handling**:

   - Works with `ValidationPipe` for invalid params.
